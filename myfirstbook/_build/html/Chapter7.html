
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Chapter: Graph Traversals &#8212; My sample book</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=87e54e7c" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'Chapter7';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Graph Shortest Paths" href="Chapter8.html" />
    <link rel="prev" title="Data Structures: Trees and Graphs" href="Chapter6.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/logo.png" class="logo__image only-light" alt="My sample book - Home"/>
    <script>document.write(`<img src="_static/logo.png" class="logo__image only-dark" alt="My sample book - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Welcome to your Jupyter Book
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="Chapter1.html">Brief History of Python programming language.</a></li>



<li class="toctree-l1"><a class="reference internal" href="Chapter2.html"><strong>Report Final. Algorithms</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter3.html">Table of contents</a></li>






<li class="toctree-l1"><a class="reference internal" href="Chapter4.html">Chapter 4</a></li>







<li class="toctree-l1"><a class="reference internal" href="Chapter5.html">Chapter: Arrays and Pointers</a></li>









<li class="toctree-l1"><a class="reference internal" href="Chapter6.html"><strong>Data Structures: Trees and Graphs</strong></a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#"><strong>Chapter: Graph Traversals</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter8.html">Graph Shortest Paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter9.html">10. Recursion, Backtracking, Recurrence Relations</a></li>
<li class="toctree-l1"><a class="reference internal" href="Chapter10.html">10. Dynamic programming</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2FChapter7.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/Chapter7.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter: Graph Traversals</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table-of-contents"><strong>TABLE OF CONTENTS:</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-graph-traversal-in-computer-science"><strong>Understanding Graph Traversal in Computer Science</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-definition-of-graph-traversal"><strong>The Definition of Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-terminology-in-graph-traversal"><strong>Key Terminology in Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-role-of-graph-traversal-in-data-structures"><strong>The Role of Graph Traversal in Data Structures</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#breadth-first-search-bfs"><strong>Breadth-First Search (BFS)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1"><strong>Example #1</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-bfs-traversal-of-a-directed-graph"><strong>Example #2 BFS Traversal of a Directed Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-and-use-cases"><strong>Applications and Use Cases</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#depth-first-search-dfs"><strong>Depth-First Search (DFS)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1"><strong>Example #1</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-dfs-traversal-of-a-directed-graph"><strong>Example #2 DFS Traversal of a Directed Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2"><strong>Applications and Use Cases</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparing-bfs-and-dfs-graph-traversal-approaches"><strong>Comparing BFS and DFS Graph Traversal Approaches</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example"><strong>Example</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exploring-different-graph-traversal-algorithms"><strong>Exploring Different Graph Traversal Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamentals-of-graph-traversal-algorithms"><strong>Fundamentals of Graph Traversal Algorithms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path-algorithms"><strong>Shortest Path Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dijkstras-algorithm"><strong>Dijkstra’s Algorithm</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bellman-ford-algorithm"><strong>Bellman-Ford Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree"><strong>Minimum Spanning Tree</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#prims-algorithm"><strong>Prim’s Algorithm</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kruskals-algorithm"><strong>Kruskal’s Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strongly-connected-components-sccs"><strong>Strongly Connected Components (SCCs)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kosarajus-algorithm"><strong>Kosaraju’s Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flow-algorithms"><strong>Flow Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ford-fulkerson-algorithm-for-maximum-flow"><strong>Ford-Fulkerson Algorithm for Maximum Flow</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#edmonds-karp-algorithm"><strong>Edmonds-Karp Algorithm</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-applications-of-graph-traversal-in-computer-science"><strong>The Applications of Graph Traversal in Computer Science</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-world-applications-of-graph-traversal"><strong>Real-World Applications of Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-graph-traversal-is-changing-the-tech-industry"><strong>How Graph Traversal is Changing the Tech Industry</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tips-for-solving-problems-with-graph-traversal-algorithms"><strong>Tips for Solving Problems with Graph Traversal Algorithms</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#leetcode-problems-related-to-graph-traversals"><strong>Leetcode Problems related to Graph Traversals</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1-number-of-provincies"><strong>Problem #1 Number of Provincies</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2-rotting-oranges"><strong>Problem #2 Rotting Oranges</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-3-flood-fill"><strong>Problem #3 Flood Fill</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-4-surrounded-regions"><strong>Problem #4 Surrounded Regions</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-5-number-of-enclaves"><strong>Problem #5 Number of Enclaves</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-6-is-graph-bipartite"><strong>Problem #6 Is Graph Bipartite?</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-7-number-of-islands"><strong>Problem #7 Number of Islands</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-8-word-ladder"><strong>Problem #8 Word Ladder</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-9-shortest-path-in-binary-matrix"><strong>Problem #9 Shortest Path in Binary Matrix</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-10-word-search"><strong>Problem #10 Word Search</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-11-symmetric-tree"><strong>Problem #11 Symmetric Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-12-path-sum"><strong>Problem #12 Path Sum</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-13-binary-tree-level-order-traversal"><strong>Problem #13 Binary Tree Level Order Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-14-pacific-atlantic-water-flow"><strong>Problem #14 Pacific Atlantic Water Flow</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-15-course-schedule"><strong>Problem #15 Course Schedule</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-16-network-delay-time"><strong>Problem #16 Network Delay Time</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-17-same-tree"><strong>Problem #17 Same Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-18-maximum-depth-of-binary-tree"><strong>Problem #18 Maximum Depth of Binary Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-19-minimum-depth-of-binary-tree"><strong>Problem #19 Minimum Depth of Binary Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-20-clone-graph"><strong>Problem #20 Clone Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-21-perfect-squares"><strong>Problem #21 Perfect Squares</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-22-coin-change"><strong>Problem #22 Coin Change</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-23-water-and-jug-problem"><strong>Problem #23 Water and Jug Problem</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-24-sum-of-left-leaves"><strong>Problem #24 Sum of Left Leaves</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-25-zuma-game"><strong>Problem #25 Zuma Game</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-26-keys-and-rooms"><strong>Problem #26 Keys and Rooms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-27-escape-the-spreading-fire"><strong>Problem #27 Escape the Spreading Fire</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-28-map-of-highest-peak"><strong>Problem #28 Map of Highest Peak</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-29-bus-routes"><strong>Problem #29 Bus Routes</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-30-as-far-from-land-as-possible"><strong>Problem #30 As Far from Land as Possible</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion"><strong>Conclusion</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways"><strong>Key takeaways</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references"><strong>References</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#useful-links"><strong>Useful links</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3"><strong>Understanding Graph Traversal in Computer Science</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4"><strong>Breadth-First Search (BFS)</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5"><strong>Depth-First Search (DFS)</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6"><strong>Exploring Different Graph Traversal Algorithms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7"><strong>The Applications of Graph Traversal in Computer Science</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tips"><strong>Tips</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problems"><strong>Problems</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-graph-traversal-key-takeaways"><strong>Solution / Graph Traversal - Key Takeaways</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#thank-you"><strong>Thank you!</strong></a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-graph-traversals">
<h1><strong>Chapter: Graph Traversals</strong><a class="headerlink" href="#chapter-graph-traversals" title="Link to this heading">#</a></h1>
<p>ID: 231107008</p>
<p>Name and Surname: Nazerke Makhsatbekkyzy</p>
<section id="table-of-contents">
<h2><strong>TABLE OF CONTENTS:</strong><a class="headerlink" href="#table-of-contents" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Understanding Graph Traversal in Computer Science</p></li>
<li><p>Breadth-First Search (BFS)</p></li>
<li><p>Depth-First Search (DFS)</p></li>
<li><p>Comparing BFS and DFS Graph Traversal Approaches</p></li>
<li><p>Exploring Different Graph Traversal Algorithms</p></li>
<li><p>The Applications of Graph Traversal in Computer Science</p></li>
<li><p>Tips for Solving Problems with Graph Traversal Algorithms</p></li>
<li><p>Leetcode Problems related to Graph Traversals</p></li>
<li><p>Conclusion</p></li>
<li><p>References</p></li>
<li><p>Useful links</p></li>
</ul>
</section>
<section id="understanding-graph-traversal-in-computer-science">
<h2><strong>Understanding Graph Traversal in Computer Science</strong><a class="headerlink" href="#understanding-graph-traversal-in-computer-science" title="Link to this heading">#</a></h2>
<p>In mathematics and computer science, a graph is a collection of nodes (also known as vertices) and edges that connect pairs of nodes. These edges may be directed or undirected, and they may have weights assigned to them. Graphs are a fundamental data structure used to represent various relationships between objects.</p>
<p>Graph traversal refers to the process of visiting, or exploring, all the vertices of a graph, ensuring each vertex is visited exactly once. A fundamental technique in computer science, graph traversal has application in various fields, from internet network routing and social networks to creating a tree spanning a computer network.</p>
<section id="the-definition-of-graph-traversal">
<h3><strong>The Definition of Graph Traversal</strong><a class="headerlink" href="#the-definition-of-graph-traversal" title="Link to this heading">#</a></h3>
<p><em>In computer science,</em></p>
<blockquote>
<div><p>Graph traversal, as the term suggests, is a technique used for traversing or visiting every vertex of a graph. In other words, it’s a systematic method of exploring every vertex (node or point) in a graph data structure.</p>
</div></blockquote>
<p>Visually a graph traversal is typically drawn as a decision tree, as shown in Fig. 1.</p>
<img src="https://b2316719.smushcdn.com/2316719/wp-content/uploads/2022/11/image-6-768x444.png?lossy=1&strip=1&webp=1" width="600">
<p>Figure 1: Example of nodes to traverse in a graph, visualized as a decision tree.</p>
<p>When traversing all the nodes through a graph, regardless of the algorithm used, we can face the following issues:
There may be cases in which the graph is not connected, therefore not all nodes can be reached.</p>
<p>In the case of cyclic (starts and ends at the same node) graphs, we should make sure that cycles do not cause the algorithm to go into an infinite loop.
We may need to visit some nodes more than once, since we do not know if a node has already been seen, before transitioning to it.</p>
<p>Graph traversal algorithms can solve the second and third problems by flagging vertices as visited when appropriate:</p>
<ol class="arabic simple">
<li><p>at first, no node is flagged as visited;</p></li>
<li><p>when the node is visited, we flag it as visited during the traversal;</p></li>
<li><p>a flagged node is not visited a second time. This keeps the program from going into an infinite loop when it encounters a cycle.</p></li>
</ol>
<p>Traversing a graph is, without a doubt, one of the most useful processes when dealing with graphs. In this blog we will describe the two most frequent methods when traversing a graph:</p>
<ul class="simple">
<li><p>Depth first search (DFS)</p></li>
<li><p>Breadth first search (BFS)</p></li>
</ul>
</section>
<section id="key-terminology-in-graph-traversal">
<h3><strong>Key Terminology in Graph Traversal</strong><a class="headerlink" href="#key-terminology-in-graph-traversal" title="Link to this heading">#</a></h3>
<p>In order to have a solid understanding of graph traversal, it is crucial to understand a few key terms:</p>
<p><em>Vertex:</em> A point or an individual node in a graph.</p>
<p><em>Edge:</em> A connection between two vertices.</p>
<p><em>Root:</em> The vertex from which the traversal starts.</p>
<p><em>BFS:</em> Breadth-First Search is a method for exploring the vertex level by level.</p>
<p><em>DFS:</em> Depth-First Search is a method for exploring the vertex deeply before moving to the next level.</p>
</section>
<section id="the-role-of-graph-traversal-in-data-structures">
<h3><strong>The Role of Graph Traversal in Data Structures</strong><a class="headerlink" href="#the-role-of-graph-traversal-in-data-structures" title="Link to this heading">#</a></h3>
<p>Graph traversal plays a pivotal role in data structures and its applications. An algorithm like DFS can be used to create a tree, called a DFS tree, or we can detect cycles in a graph. BFS can be used to find the shortest path in a graph.
For example, in a social networking site, graph traversal techniques like BFS or DFS could be used to find out the connection – or path – between two people.</p>
</section>
</section>
<section id="breadth-first-search-bfs">
<h2><strong>Breadth-First Search (BFS)</strong><a class="headerlink" href="#breadth-first-search-bfs" title="Link to this heading">#</a></h2>
<p><strong>Explanation and Algorithm</strong></p>
<p>Breadth-First Search (BFS) is a fundamental graph traversal algorithm that explores all the vertices of a graph in breadthward motion. It starts from a selected node (or vertex) and explores all its neighbors at the present depth before moving on to nodes at the next depth level.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Begin with a starting node, mark it as visited, and enqueue it in a queue.</p></li>
<li><p>While the queue is not empty:
Dequeue a node from the queue.
Visit and process the node.
Enqueue all unvisited neighbors of the node.</p></li>
<li><p>Continue this process until all nodes are visited.</p></li>
</ol>
<p><strong>HOW DOES IT WORK CONCEPTUALLY?</strong></p>
<p>The BFS algorithm starts by searching a start node, followed by its adjacent nodes, then all nodes that can be reached by a path from the start node containing two edges, three edges, and so on.
In the example below from Fig. 3, the root node would be node “0”; we traverse in width through node “1”, followed by node “2”. Once we have traversed through all nodes in the first depth level, we move to the second depth level, starting with node “3”, and moving through nodes “4”, “5”, and “6”.</p>
<img src="https://b2316719.smushcdn.com/2316719/wp-content/uploads/2022/11/dfs_animated-1.gif?lossy=1&strip=1&webp=1" width="600">
<p>Figure 2: DFS Algorithm, step by step (example #1)</p>
<section id="example-1">
<h3><strong>Example #1</strong><a class="headerlink" href="#example-1" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>         <span class="c1"># Initialize queue with starting node and its depth</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                  <span class="c1"># Mark starting node as visited</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>                        <span class="c1"># Continue until queue is empty</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>   <span class="c1"># Dequeue a node and its depth from the queue</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Traversing node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> at depth </span><span class="si">{</span><span class="n">depth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Print the traversed node and its depth</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>    <span class="c1"># Explore neighbors of the current node</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="c1"># If neighbor is not visited</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># Enqueue the neighbor with its depth</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>   <span class="c1"># Mark neighbor as visited</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform BFS starting from node &#39;0&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>BFS Traversal:
Traversing node 0 at depth 0
Traversing node 1 at depth 1
Traversing node 2 at depth 1
Traversing node 3 at depth 2
Traversing node 4 at depth 2
Traversing node 5 at depth 3
Traversing node 6 at depth 3
</pre></div>
</div>
</div>
</div>
<p>Explanation of the provided code:</p>
<ol class="arabic simple">
<li><p><strong>Importing Libraries</strong>: The code starts by importing the <code class="docutils literal notranslate"><span class="pre">deque</span></code> class from the <code class="docutils literal notranslate"><span class="pre">collections</span></code> module. This is used to implement the queue data structure efficiently.</p></li>
<li><p><strong>Defining the BFS Function</strong>: The <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function takes two arguments: <code class="docutils literal notranslate"><span class="pre">graph</span></code>, which represents the graph as an adjacency list, and <code class="docutils literal notranslate"><span class="pre">start</span></code>, which specifies the starting node for the BFS traversal.</p></li>
<li><p><strong>Initialization</strong>: Inside the <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function, a set called <code class="docutils literal notranslate"><span class="pre">visited</span></code> is initialized to keep track of visited nodes. The <code class="docutils literal notranslate"><span class="pre">queue</span></code> is initialized as a deque containing tuples <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">0)</span></code>, where <code class="docutils literal notranslate"><span class="pre">start</span></code> is the starting node and <code class="docutils literal notranslate"><span class="pre">0</span></code> is the depth of the starting node.</p></li>
<li><p><strong>BFS Traversal</strong>: The while loop continues until the queue is empty. At each iteration, a node and its depth are dequeued from the front of the queue using <code class="docutils literal notranslate"><span class="pre">popleft()</span></code>.</p></li>
<li><p><strong>Printing the Traversed Node</strong>: The traversed node and its depth are printed to demonstrate the BFS traversal order.</p></li>
<li><p><strong>Exploring Neighbors</strong>: For each neighbor of the current node, if the neighbor has not been visited, it is added to the queue along with its depth (depth + 1), and marked as visited.</p></li>
<li><p><strong>Example Graph</strong>: The example graph is represented as an adjacency list where each node is a key, and its adjacent nodes are stored as values in a list.</p></li>
<li><p><strong>Calling the BFS Function</strong>: Finally, the BFS function is called with the example graph and the starting node ‘0’ to perform the BFS traversal.</p></li>
</ol>
<p>This code demonstrates how BFS traverses the graph in breadth-first order, starting from the root node and exploring all nodes at each level before moving to the next level. The depth of each node is printed during traversal to illustrate the BFS approach.</p>
</section>
<section id="example-2-bfs-traversal-of-a-directed-graph">
<h3><strong>Example #2 BFS Traversal of a Directed Graph</strong><a class="headerlink" href="#example-2-bfs-traversal-of-a-directed-graph" title="Link to this heading">#</a></h3>
<p>Consider the following directed graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">--&gt;</span> <span class="mi">1</span> <span class="o">--&gt;</span> <span class="mi">2</span>
   <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>
   <span class="n">v</span>     <span class="n">v</span>     <span class="n">v</span>
   <span class="mi">3</span> <span class="o">--&gt;</span> <span class="mi">4</span> <span class="o">--&gt;</span> <span class="mi">5</span>
</pre></div>
</div>
<p>We will perform BFS traversal starting from node 0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>              <span class="c1"># Initialize queue with starting node</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                  <span class="c1"># Mark starting node as visited</span>

    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>                      <span class="c1"># Create an undirected graph object</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>      <span class="c1"># Add nodes to the graph</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>                        <span class="c1"># Continue until queue is empty</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>          <span class="c1"># Dequeue a node from the queue</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>    <span class="c1"># Explore neighbors of the current node</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="c1"># If neighbor is not visited</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># Enqueue the neighbor</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>   <span class="c1"># Mark neighbor as visited</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># Add edge to the graph</span>

    <span class="k">return</span> <span class="n">G</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="n">start_node</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">bfs_graph</span> <span class="o">=</span> <span class="n">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)</span>    <span class="c1"># Get the BFS traversal graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">bfs_graph</span><span class="p">)</span>     <span class="c1"># Calculate node positions</span>

<span class="c1"># Draw the graph</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">bfs_graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;BFS Traversal Graph&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;networkx&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>              <span class="c1"># Initialize queue with starting node</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                  <span class="c1"># Mark starting node as visited</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>                        <span class="c1"># Continue until queue is empty</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>          <span class="c1"># Dequeue a node from the queue</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>            <span class="c1"># Print the traversed node</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>    <span class="c1"># Explore neighbors of the current node</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="c1"># If neighbor is not visited</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># Enqueue the neighbor</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>   <span class="c1"># Mark neighbor as visited</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform BFS starting from node &#39;0&#39;</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Importing Libraries</strong>: We import the <code class="docutils literal notranslate"><span class="pre">deque</span></code> class from the <code class="docutils literal notranslate"><span class="pre">collections</span></code> module to implement the queue efficiently.</p></li>
<li><p><strong>Defining the BFS Function</strong>: The <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function takes two arguments: <code class="docutils literal notranslate"><span class="pre">graph</span></code>, which represents the graph as an adjacency list, and <code class="docutils literal notranslate"><span class="pre">start</span></code>, which specifies the starting node for the BFS traversal.</p></li>
<li><p><strong>Initialization</strong>: Inside the <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function, we initialize a set called <code class="docutils literal notranslate"><span class="pre">visited</span></code> to keep track of visited nodes. The <code class="docutils literal notranslate"><span class="pre">queue</span></code> is initialized as a deque containing the starting node.</p></li>
<li><p><strong>BFS Traversal</strong>: We perform BFS traversal using a while loop that continues until the queue is empty. At each iteration, we dequeue a node from the front of the queue and print it.</p></li>
<li><p><strong>Exploring Neighbors</strong>: For each neighbor of the current node, if the neighbor has not been visited, we enqueue it and mark it as visited.</p></li>
<li><p><strong>Example Graph</strong>: The example graph is represented as an adjacency list where each node is a key, and its adjacent nodes are stored as values in a list.</p></li>
<li><p><strong>Calling the BFS Function</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function with the example graph and the starting node <code class="docutils literal notranslate"><span class="pre">'0'</span></code> to perform the BFS traversal.</p></li>
</ol>
<p>This code demonstrates how BFS traversal explores nodes level by level, starting from the root node (<code class="docutils literal notranslate"><span class="pre">'0'</span></code>) and visiting all its neighbors before moving to the next level. The traversal order is <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">3</span> <span class="pre">2</span> <span class="pre">4</span> <span class="pre">5</span></code>.</p>
</section>
<section id="applications-and-use-cases">
<h3><strong>Applications and Use Cases</strong><a class="headerlink" href="#applications-and-use-cases" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Shortest Path: BFS finds the shortest path in unweighted graphs, where the number of edges measures the path length.</p></li>
<li><p>Network Broadcasting: It’s employed in network routing algorithms to broadcast messages to all nodes efficiently.</p></li>
<li><p>Web Crawling: Search engines like Google use BFS to index web pages by following links from one page to another.</p></li>
</ul>
</section>
</section>
<section id="depth-first-search-dfs">
<h2><strong>Depth-First Search (DFS)</strong><a class="headerlink" href="#depth-first-search-dfs" title="Link to this heading">#</a></h2>
<p><strong>Explanation and Algorithm</strong></p>
<p>Depth-first search (DFS) is another fundamental graph traversal algorithm that explores all the vertices of a graph by going as deep as possible along each branch before backtracking. It starts from a selected node and explores as far as possible along each branch before moving back.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Begin with a starting node and mark it as visited.</p></li>
<li><p>For each unvisited neighbor of the node:
Recur with the neighbor as the new starting node.</p></li>
<li><p>Continue this process until all nodes are visited.</p></li>
</ol>
<p><strong>HOW DOES IT WORK CONCEPTUALLY?</strong></p>
<p>The DFS algorithm starts at the root (top) node of a tree and goes as far as it can down a given branch (path), then backtracks until it finds an unexplored path, and then explores it. The algorithm does this until the entire graph has been explored.</p>
<p>In the example shown in Fig. 2, the root node would be node “0”; we traverse in depth through node “1”, followed by node “3”. Once we reach the node, we move one level up to node “1” and traverse through all other connected nodes, in this case, node “4”. Once we have covered all connected nodes, we move again one level up, to node “0” and traverse all other connected nodes, in this case, node “2”. As we traverse through deeper nodes, we traverse through nodes “5” and “6”, covering all connected nodes.</p>
<img src="https://b2316719.smushcdn.com/2316719/wp-content/uploads/2022/11/bfs_animated-1.gif?lossy=1&strip=1&webp=1" width="600">
<p>Figure 3: BFS Algorithm, step by step (example #1)</p>
<section id="id1">
<h3><strong>Example #1</strong><a class="headerlink" href="#id1" title="Link to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                      <span class="c1"># Mark current node as visited</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>                   <span class="c1"># Print the traversed node</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>           <span class="c1"># Explore neighbors of the current node</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>         <span class="c1"># If neighbor is not visited</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>   <span class="c1"># Recursively call DFS for the neighbor</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform DFS starting from node &#39;0&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DFS Traversal:
0 1 3 4 2 5 6 
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining the DFS Function</strong>: The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function takes three arguments: <code class="docutils literal notranslate"><span class="pre">graph</span></code>, which represents the graph as an adjacency list, <code class="docutils literal notranslate"><span class="pre">start</span></code>, which specifies the starting node for the DFS traversal, and <code class="docutils literal notranslate"><span class="pre">visited</span></code>, which is a set to keep track of visited nodes. If <code class="docutils literal notranslate"><span class="pre">visited</span></code> is not provided, it is initialized as an empty set.</p></li>
<li><p><strong>Base Case</strong>: If the current node (<code class="docutils literal notranslate"><span class="pre">start</span></code>) has not been visited, it is added to the <code class="docutils literal notranslate"><span class="pre">visited</span></code> set and printed as the traversed node.</p></li>
<li><p><strong>Recursive Exploration</strong>: For each neighbor of the current node, if the neighbor has not been visited, the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is recursively called for that neighbor.</p></li>
<li><p><strong>Example Graph</strong>: The example graph is represented as an adjacency list where each node is a key, and its adjacent nodes are stored as values in a list.</p></li>
<li><p><strong>Calling the DFS Function</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function with the example graph and the starting node <code class="docutils literal notranslate"><span class="pre">'0'</span></code> to perform the DFS traversal.</p></li>
</ol>
<p>This code demonstrates how DFS traversal explores nodes depth-first, starting from the root node (<code class="docutils literal notranslate"><span class="pre">'0'</span></code>) and traversing as far down each branch as possible before backtracking. The traversal order is <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">3</span> <span class="pre">4</span> <span class="pre">2</span> <span class="pre">5</span> <span class="pre">6</span></code>.</p>
</section>
<section id="example-2-dfs-traversal-of-a-directed-graph">
<h3><strong>Example #2 DFS Traversal of a Directed Graph</strong><a class="headerlink" href="#example-2-dfs-traversal-of-a-directed-graph" title="Link to this heading">#</a></h3>
<p>Consider the following directed graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">--&gt;</span> <span class="mi">1</span> <span class="o">--&gt;</span> <span class="mi">2</span>
   <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>
   <span class="n">v</span>     <span class="n">v</span>     <span class="n">v</span>
   <span class="mi">3</span> <span class="o">--&gt;</span> <span class="mi">4</span> <span class="o">--&gt;</span> <span class="mi">5</span>
</pre></div>
</div>
<p>We will perform DFS traversal starting from node 0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">visited_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="k">if</span> <span class="n">visited_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited_list</span> <span class="o">=</span> <span class="p">[]</span>                   <span class="c1"># List to store visited nodes in order</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                      <span class="c1"># Mark current node as visited</span>
    <span class="n">visited_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>              <span class="c1"># Add current node to visited list</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>                   <span class="c1"># Print the traversed node</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>           <span class="c1"># Explore neighbors of the current node</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>         <span class="c1"># If neighbor is not visited</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">visited_list</span><span class="p">)</span>   <span class="c1"># Recursively call DFS for the neighbor</span>

    <span class="k">return</span> <span class="n">visited_list</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="n">start_node</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">visited_list</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)</span>    <span class="c1"># Perform DFS starting from node &#39;0&#39;</span>

<span class="c1"># Create a directed graph object for the DFS traversal</span>
<span class="n">G_dfs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="n">G_dfs</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>  <span class="c1"># Add nodes to the graph</span>

<span class="c1"># Add edges based on the DFS traversal order</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">visited_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">G_dfs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">visited_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">visited_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos_dfs</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G_dfs</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G_dfs</span><span class="p">,</span> <span class="n">pos_dfs</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightcoral&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;DFS Traversal Graph&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DFS Traversal:
0 1 2 5 4 3 
</pre></div>
</div>
<img alt="_images/470b489c0a15bfc6e126c85f3e575877eab83b66cc82e3ff6d4ea7b7957e8441.png" src="_images/470b489c0a15bfc6e126c85f3e575877eab83b66cc82e3ff6d4ea7b7957e8441.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                      <span class="c1"># Mark current node as visited</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>                   <span class="c1"># Print the traversed node</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>           <span class="c1"># Explore neighbors of the current node</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>         <span class="c1"># If neighbor is not visited</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>   <span class="c1"># Recursively call DFS for the neighbor</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;5&#39;</span><span class="p">],</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DFS Traversal:&quot;</span><span class="p">)</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform DFS starting from node &#39;0&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DFS Traversal:
0 1 2 5 4 3 
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining the DFS Function</strong>: The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function takes three arguments: <code class="docutils literal notranslate"><span class="pre">graph</span></code>, which represents the graph as an adjacency list, <code class="docutils literal notranslate"><span class="pre">start</span></code>, which specifies the starting node for the DFS traversal, and <code class="docutils literal notranslate"><span class="pre">visited</span></code>, which is a set to keep track of visited nodes. If <code class="docutils literal notranslate"><span class="pre">visited</span></code> is not provided, it is initialized as an empty set.</p></li>
<li><p><strong>Base Case</strong>: If the current node (<code class="docutils literal notranslate"><span class="pre">start</span></code>) has not been visited, it is added to the <code class="docutils literal notranslate"><span class="pre">visited</span></code> set and printed as the traversed node.</p></li>
<li><p><strong>Recursive Exploration</strong>: For each neighbor of the current node, if the neighbor has not been visited, the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function is recursively called for that neighbor.</p></li>
<li><p><strong>Example Graph</strong>: The example graph is represented as an adjacency list where each node is a key, and its adjacent nodes are stored as values in a list.</p></li>
<li><p><strong>Calling the DFS Function</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function with the example graph and the starting node <code class="docutils literal notranslate"><span class="pre">'0'</span></code> to perform the DFS traversal.</p></li>
</ol>
<p>This code demonstrates how DFS traversal explores nodes depth-first, starting from the root node (<code class="docutils literal notranslate"><span class="pre">'0'</span></code>) and traversing as far down each branch as possible before backtracking. The traversal order is <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">5</span> <span class="pre">4</span> <span class="pre">3</span></code>.</p>
</section>
<section id="id2">
<h3><strong>Applications and Use Cases</strong><a class="headerlink" href="#id2" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Cycle Detection: DFS can detect cycles in a graph, essential in tasks like deadlock detection.</p></li>
<li><p>Topological Sorting: It’s used to sort the vertices of a directed acyclic graph (DAG) in a linear order.</p></li>
<li><p>Maze Solving: DFS can be used to find a path through a maze by exploring possible routes.</p></li>
<li><p>Strongly Connected Components: In directed graphs, DFS is used to find strongly connected components, which are sets of nodes where each node is reachable from every other node.</p></li>
</ul>
<p>These two techniques are used extensively in a variety of scenarios. For instance, when finding the shortest path between two points in an unweighted graph or level order traversal of a tree, BFS is used. On the other hand, DFS is the preferred method when performing tasks like Topological Sorting or detecting a cycle in a graph.</p>
</section>
</section>
<section id="comparing-bfs-and-dfs-graph-traversal-approaches">
<h2><strong>Comparing BFS and DFS Graph Traversal Approaches</strong><a class="headerlink" href="#comparing-bfs-and-dfs-graph-traversal-approaches" title="Link to this heading">#</a></h2>
<p>While BFS and DFS are both effective graph traversal methods, they have distinct characteristics and use-cases. Here’s is a comparative overview of BFS and DFS:</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Criteria</p></th>
<th class="head"><p>BFS</p></th>
<th class="head"><p>DFS</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Traversal Order</p></td>
<td><p>Vertex level by level</p></td>
<td><p>Depth first, retraces when hits a dead end</p></td>
</tr>
<tr class="row-odd"><td><p>Data Structure Used</p></td>
<td><p>Queue</p></td>
<td><p>Stack</p></td>
</tr>
<tr class="row-even"><td><p>Example of Use Case</p></td>
<td><p>Shortest path in an unweighted graph</p></td>
<td><p>Topological Sorting, detecting a cycle in a graph</p></td>
</tr>
</tbody>
</table>
</div>
<section id="example">
<h3><strong>Example</strong><a class="headerlink" href="#example" title="Link to this heading">#</a></h3>
<p>Consider the following undirected graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span>
  <span class="o">/</span> \
 <span class="mi">1</span><span class="o">---</span><span class="mi">2</span>
 <span class="o">|</span>   <span class="o">|</span>
 <span class="mi">3</span><span class="o">---</span><span class="mi">4</span>

</pre></div>
</div>
<p>We’ll perform BFS and DFS traversal starting from node 0 and observe the traversal order.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>              <span class="c1"># Initialize queue with starting node</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                  <span class="c1"># Mark starting node as visited</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BFS Traversal:&quot;</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>                        <span class="c1"># Continue until queue is empty</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>          <span class="c1"># Dequeue a node from the front of the queue</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>            <span class="c1"># Print the traversed node</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>    <span class="c1"># Explore neighbors of the current node</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="c1"># If neighbor is not visited</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  <span class="c1"># Enqueue the neighbor</span>
                <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>   <span class="c1"># Mark neighbor as visited</span>

<span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                     <span class="c1"># Set to store visited nodes</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>                      <span class="c1"># Mark current node as visited</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">)</span>                   <span class="c1"># Print the traversed node</span>

    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>           <span class="c1"># Explore neighbors of the current node</span>
        <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>         <span class="c1"># If neighbor is not visited</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>   <span class="c1"># Recursively call DFS for the neighbor</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">],</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform BFS starting from node &#39;0&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>    <span class="c1"># Perform DFS starting from node &#39;0&#39;</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>BFS Traversal:
0 1 2 3 4 

0 1 2 4 3 
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining BFS and DFS Functions</strong>: We define <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and <code class="docutils literal notranslate"><span class="pre">dfs</span></code> functions to perform BFS and DFS traversal, respectively. Both functions take the graph represented as an adjacency list and the starting node as input.</p></li>
<li><p><strong>BFS Traversal</strong>: In the <code class="docutils literal notranslate"><span class="pre">bfs</span></code> function, we use a queue to implement BFS traversal. We start by enqueueing the starting node and mark it as visited. Then, we continue dequeuing nodes from the queue, visiting their neighbors, and enqueueing unvisited neighbors until the queue is empty. We print the traversal order as we visit each node.</p></li>
<li><p><strong>DFS Traversal</strong>: In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function, we use recursion to implement DFS traversal. We start by marking the current node as visited and print it. Then, we recursively call DFS for each unvisited neighbor of the current node. This results in traversing nodes in depth-first order, printing the traversal order as we visit each node.</p></li>
<li><p><strong>Example Graph</strong>: We represent the example graph as an adjacency list where each node is a key, and its adjacent nodes are stored as values in a list.</p></li>
<li><p><strong>Performing Traversals</strong>: Finally, we call both BFS and DFS functions with the example graph and the starting node <code class="docutils literal notranslate"><span class="pre">'0'</span></code> to compare their traversal orders. We observe the difference in traversal order between BFS and DFS approaches.</p></li>
</ol>
</section>
</section>
<section id="exploring-different-graph-traversal-algorithms">
<h2><strong>Exploring Different Graph Traversal Algorithms</strong><a class="headerlink" href="#exploring-different-graph-traversal-algorithms" title="Link to this heading">#</a></h2>
<p>There exist numerous algorithms for traversing graphs, born out of the diversity of problems that use graphs as their core data structure. While Breadth-First Search (BFS) and Depth-First Search (DFS) are the most prominent and fundamental methods, other useful algorithms include Dijkstra’s algorithm, A* Search, Bellman-Ford algorithm, and Floyd-Warshall algorithm.</p>
<section id="fundamentals-of-graph-traversal-algorithms">
<h3><strong>Fundamentals of Graph Traversal Algorithms</strong><a class="headerlink" href="#fundamentals-of-graph-traversal-algorithms" title="Link to this heading">#</a></h3>
<p>Understanding graph traversal requires an insight into the fundamentals of these algorithms and how they work.</p>
</section>
<section id="shortest-path-algorithms">
<h3><strong>Shortest Path Algorithms</strong><a class="headerlink" href="#shortest-path-algorithms" title="Link to this heading">#</a></h3>
<section id="dijkstras-algorithm">
<h4><strong>Dijkstra’s Algorithm</strong><a class="headerlink" href="#dijkstras-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>Dijkstra’s Algorithm is a widely used and efficient algorithm for finding the shortest path between nodes in a weighted graph. It works by maintaining a set of tentative distances to every node and iteratively updating these distances based on the actual distances found.</p>
<p>Algorithm:</p>
<ol class="arabic simple">
<li><p>Initialize a distance table with tentative distances to all nodes, setting the space to the starting node as 0 and all others as infinity.</p></li>
<li><p>Set the starting node as the current node.</p></li>
<li><p>For each neighbor of the current node, calculate its tentative distance and update the distance table if a shorter path is found.</p></li>
<li><p>Mark the current node as visited.</p></li>
<li><p>Select the unvisited node with the smallest tentative distance, set it as the new current node, and repeat steps 3–5.</p></li>
<li><p>Continue this process until the destination node is marked as visited or until all nodes have been called.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Navigation and Maps: Dijkstra’s Algorithm is used in GPS systems to find the shortest route between two locations.</p></li>
<li><p>Networking and Routing: It’s employed in determining the optimal path for data transmission in computer networks.</p></li>
<li><p>Transportation and Logistics: Dijkstra’s Algorithm helps optimize routes for delivery services and public transportation.</p></li>
</ul>
<p><strong>Example of Dijkstra’s algorithm applied to find the shortest paths from a single source node to all other nodes in a weighted directed graph:</strong></p>
<p>The problem is finding the shortest paths from a single source node to all other nodes in a weighted directed graph. This is achieved using Dijkstra’s algorithm, which efficiently computes the shortest distances from the specified source node to all other nodes in the graph. The algorithm takes as input the graph represented as an adjacency list with weighted edges and the start node, and it outputs a dictionary containing the shortest distances from the start node to each node in the graph. The code demonstrates the application of Dijkstra’s algorithm to find the shortest distances from a specified source node ‘A’ to all other nodes in the example graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Add edge labels</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Dijkstra&#39;s algorithm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/a9348d0a7b2474047e65241712506a32a82dacbd807dbf366b8e9b074bbc5509.png" src="_images/a9348d0a7b2474047e65241712506a32a82dacbd807dbf366b8e9b074bbc5509.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">dijkstra</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="c1"># Initialize distances to all nodes as infinity</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Distance from start node to itself is 0</span>

    <span class="c1"># Priority queue to store nodes with their distances</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span>  <span class="c1"># Priority queue with (distance, node) pairs</span>

    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
        <span class="n">current_distance</span><span class="p">,</span> <span class="n">current_node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>  <span class="c1"># Pop node with smallest distance</span>
        <span class="c1"># If we have already found a shorter path to the current node, skip it</span>
        <span class="k">if</span> <span class="n">current_distance</span> <span class="o">&gt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">current_node</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="c1"># Explore neighbors of the current node</span>
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">current_node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">current_distance</span> <span class="o">+</span> <span class="n">weight</span>
            <span class="c1"># If the new distance is shorter than the existing one, update the distance</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>  <span class="c1"># Push neighbor with its updated distance to the priority queue</span>

    <span class="k">return</span> <span class="n">distances</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="n">start_node</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shortest distances from node </span><span class="si">{</span><span class="n">start_node</span><span class="si">}</span><span class="s2"> using Dijkstra&#39;s algorithm:&quot;</span><span class="p">)</span>
<span class="n">distances</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;To node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shortest distances from node A using Dijkstra&#39;s algorithm:
To node A: 0
To node B: 4
To node C: 3
To node D: 4
To node E: 6
To node F: 7
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining Dijkstra’s Function</strong>: We define the <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> function that takes the graph represented as an adjacency list and the start node as input. This function computes and returns the shortest distances from the start node to all other nodes in the graph.</p></li>
<li><p><strong>Initialization</strong>: We initialize a dictionary called <code class="docutils literal notranslate"><span class="pre">distances</span></code> to store the shortest distances to all nodes. Initially, distances to all nodes except the start node are set to infinity. The distance from the start node to itself is set to 0.</p></li>
<li><p><strong>Priority Queue</strong>: We use a priority queue implemented with a heap to keep track of nodes and their distances. Nodes are prioritized based on their distances, with nodes having smaller distances given higher priority.</p></li>
<li><p><strong>Main Loop</strong>: In each iteration of the main loop, we pop the node with the smallest distance from the priority queue. We explore its neighbors and update their distances if a shorter path is found through the current node.</p></li>
<li><p><strong>Updating Distances</strong>: If the new distance to a neighbor node is shorter than its existing distance, we update the distance and push the neighbor node with its updated distance to the priority queue.</p></li>
<li><p><strong>Return</strong>: After traversing all nodes, we return the <code class="docutils literal notranslate"><span class="pre">distances</span></code> dictionary containing the shortest distances from the start node to all other nodes in the graph.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list with weighted edges.</p></li>
<li><p><strong>Performing Dijkstra’s Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">dijkstra</span></code> function with the example graph and the start node <code class="docutils literal notranslate"><span class="pre">'A'</span></code> to compute the shortest distances from node <code class="docutils literal notranslate"><span class="pre">'A'</span></code>. The shortest distances to all other nodes are printed as the output.</p></li>
</ol>
</section>
<section id="bellman-ford-algorithm">
<h4><strong>Bellman-Ford Algorithm</strong><a class="headerlink" href="#bellman-ford-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>The Bellman-Ford Algorithm finds the shortest paths in weighted graphs, even with opposing weight edges. It works by iteratively relaxing the edges in the chart.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Initialize distance values to all nodes as infinity and set the distance to the starting node as 0.</p></li>
<li><p>Relax all edges (repeat |V| — 1 times):
For each edge (u, v) with weight w, if dist[u] + w &lt; dist[v], update dist[v] = dist[u] + w.</p></li>
<li><p>Check for negative-weight cycles:
If any relaxation step further reduces the distance, a negative-weight cycle exists.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Routing in Networks: The Bellman-Ford algorithm is used in routing protocols like RIP (Routing Information Protocol) for finding the shortest path in computer networks.</p></li>
<li><p>Arbitrage Detection: It’s employed in financial markets to detect opportunities for arbitrage by identifying negative-weight cycles in currency exchange rates.</p></li>
<li><p>Traffic Engineering: Bellman-Ford can be used in traffic engineering to find optimal routes for data transmission in networks with varying link costs.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>The Bellman-Ford algorithm addresses the problem of finding the shortest paths from a single source node to all other nodes in a weighted directed graph, even in the presence of negative edge weights or cycles. It is particularly useful when dealing with graphs that may contain negative edge weights.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following weighted directed graph:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Add edge labels</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Bellman-Ford Algorithm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e7c74df3d9c1401124862d4b53757e351e6fa8e0a582c988134468273fe1ee95.png" src="_images/e7c74df3d9c1401124862d4b53757e351e6fa8e0a582c988134468273fe1ee95.png" />
</div>
</div>
<p><strong>Code and Explanation:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="c1"># Step 1: Initialize distances from start node to all other nodes as infinity</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="n">distances</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Distance from start node to itself is 0</span>

    <span class="c1"># Step 2: Relax edges repeatedly</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Relax the edge if a shorter path is found</span>
                <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span>

    <span class="c1"># Step 3: Check for negative cycles</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># If relaxing an edge still reduces the distance, a negative cycle exists</span>
            <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Graph contains a negative cycle&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">distances</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="n">start_node</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shortest distances from node </span><span class="si">{</span><span class="n">start_node</span><span class="si">}</span><span class="s2"> using Bellman-Ford algorithm:&quot;</span><span class="p">)</span>
<span class="n">distances</span> <span class="o">=</span> <span class="n">bellman_ford</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;To node </span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">distance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining the Bellman-Ford Function</strong>: The <code class="docutils literal notranslate"><span class="pre">bellman_ford</span></code> function takes the graph represented as an adjacency list and the start node as input. It computes and returns the shortest distances from the start node to all other nodes in the graph.</p></li>
<li><p><strong>Initialization</strong>: We initialize a dictionary called <code class="docutils literal notranslate"><span class="pre">distances</span></code> to store the shortest distances to all nodes. Initially, distances to all nodes except the start node are set to infinity. The distance from the start node to itself is set to 0.</p></li>
<li><p><strong>Relaxing Edges</strong>: We relax each edge repeatedly for <code class="docutils literal notranslate"><span class="pre">|V|</span> <span class="pre">-</span> <span class="pre">1</span></code> iterations, where <code class="docutils literal notranslate"><span class="pre">|V|</span></code> is the number of nodes in the graph. In each iteration, we check each edge and update the distance if a shorter path is found.</p></li>
<li><p><strong>Negative Cycle Detection</strong>: After relaxing all edges, we check for negative cycles. If relaxing an edge still reduces the distance, it means a negative cycle exists in the graph.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list with weighted edges.</p></li>
<li><p><strong>Performing Bellman-Ford Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">bellman_ford</span></code> function with the example graph and the start node <code class="docutils literal notranslate"><span class="pre">'0'</span></code> to compute the shortest distances from node <code class="docutils literal notranslate"><span class="pre">'0'</span></code>. The shortest distances to all other nodes are printed as the output.</p></li>
</ol>
</section>
</section>
<section id="minimum-spanning-tree">
<h3><strong>Minimum Spanning Tree</strong><a class="headerlink" href="#minimum-spanning-tree" title="Link to this heading">#</a></h3>
<section id="prims-algorithm">
<h4><strong>Prim’s Algorithm</strong><a class="headerlink" href="#prims-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong>
Prim’s Algorithm is a widely used algorithm for finding the minimum spanning tree of a weighted undirected graph. It starts from an arbitrary node and iteratively adds the closest unvisited node to the tree, ensuring that it forms a minimum-spanning tree.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Initialize a tree with a single node (any arbitrary node).</p></li>
<li><p>While there are still nodes not in the tree:
Find the minimum-weight edge that connects a node in the tree to a node outside the tree.
Add the node with the minimum-weight edge to the tree.</p></li>
<li><p>Continue this process until all nodes are in the tree.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Network Design: Prim’s Algorithm is used in designing cost-efficient networks, such as electrical grids or computer networks.</p></li>
<li><p>Cluster Analysis: It’s employed in grouping related data points in applications like data mining and machine learning.</p></li>
<li><p>Approximation Algorithms: Prim’s Algorithm is used as a building block in approximation algorithms for solving optimization problems.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>Prim’s algorithm addresses the problem of finding the minimum spanning tree (MST) of a connected, undirected graph. The minimum spanning tree is a subset of the edges of the graph that forms a tree, connecting all the vertices together with the minimum possible total edge weight.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following undirected graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">--</span><span class="mi">1</span><span class="o">--&gt;</span> <span class="mi">1</span> <span class="o">--</span><span class="mi">3</span><span class="o">--&gt;</span> <span class="mi">2</span>
   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>
   <span class="n">v</span>           <span class="n">v</span>     <span class="n">v</span>
   <span class="mi">3</span> <span class="o">---</span><span class="mi">2</span><span class="o">---&gt;</span>  <span class="mi">4</span> <span class="o">--</span><span class="mi">4</span><span class="o">--&gt;</span> <span class="mi">5</span>

</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Create a graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Add edge labels</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Prim’s Algorithm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/786dffd3264a4a2acfdb61d7a291742efab64fef85bc427fd69017b92703c0a8.png" src="_images/786dffd3264a4a2acfdb61d7a291742efab64fef85bc427fd69017b92703c0a8.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">def</span> <span class="nf">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">mst</span> <span class="o">=</span> <span class="p">[]</span>                                    <span class="c1"># Initialize minimum spanning tree</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>                             <span class="c1"># Set to store visited nodes</span>
    <span class="n">start_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>          <span class="c1"># Start from any node in the graph</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">start_node</span><span class="p">)</span>                     <span class="c1"># Mark starting node as visited</span>
    <span class="n">min_heap</span> <span class="o">=</span> <span class="p">[(</span><span class="n">weight</span><span class="p">,</span> <span class="n">start_node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start_node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="n">heapq</span><span class="o">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>                     <span class="c1"># Initialize min heap with edges connected to starting node</span>

    <span class="k">while</span> <span class="n">min_heap</span><span class="p">:</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">min_heap</span><span class="p">)</span>  <span class="c1"># Pop edge with minimum weight</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>                    <span class="c1"># If the destination node is not visited</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>                      <span class="c1"># Mark destination node as visited</span>
            <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>          <span class="c1"># Add edge to the minimum spanning tree</span>

            <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">min_heap</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>  <span class="c1"># Add edges connected to the visited node to the min heap</span>

    <span class="k">return</span> <span class="n">mst</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Perform Prim&#39;s algorithm to find the minimum spanning tree</span>
<span class="n">mst_edges</span> <span class="o">=</span> <span class="n">prim</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum Spanning Tree Edges:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">mst_edges</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Minimum Spanning Tree Edges:
(&#39;0&#39;, &#39;1&#39;, 1)
(&#39;0&#39;, &#39;3&#39;, 2)
(&#39;3&#39;, &#39;4&#39;, 2)
(&#39;1&#39;, &#39;2&#39;, 3)
(&#39;2&#39;, &#39;5&#39;, 4)
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Defining Prim’s Algorithm Function</strong>: The <code class="docutils literal notranslate"><span class="pre">prim</span></code> function takes the graph represented as an adjacency list as input. It computes and returns the minimum spanning tree of the graph using Prim’s algorithm.</p></li>
<li><p><strong>Initialization</strong>: We initialize an empty list <code class="docutils literal notranslate"><span class="pre">mst</span></code> to store the edges of the minimum spanning tree, and a set <code class="docutils literal notranslate"><span class="pre">visited</span></code> to store the visited nodes during the algorithm.</p></li>
<li><p><strong>Starting Node Selection</strong>: We select any node in the graph as the starting node (<code class="docutils literal notranslate"><span class="pre">start_node</span></code>). In this implementation, we select the first node in the adjacency list.</p></li>
<li><p><strong>Main Loop</strong>: We maintain a min heap <code class="docutils literal notranslate"><span class="pre">min_heap</span></code> to keep track of edges with minimum weights connected to visited nodes. We iteratively select the edge with the minimum weight from the min heap, add it to the minimum spanning tree, mark its destination node as visited, and add edges connected to the visited node to the min heap if they lead to unvisited nodes.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list with weighted edges.</p></li>
<li><p><strong>Performing Prim’s Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">prim</span></code> function with the example graph to compute the minimum spanning tree. We then create a graph object for the minimum spanning tree and draw it using NetworkX and Matplotlib libraries. The resulting graph displays the minimum spanning tree generated by Prim’s algorithm.</p></li>
</ol>
</section>
<section id="kruskals-algorithm">
<h4><strong>Kruskal’s Algorithm</strong><a class="headerlink" href="#kruskals-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>Kruskal’s Algorithm is another method for finding the minimum spanning tree of a weighted undirected graph. Instead of starting from a node, it initially treats each node as a separate tree and then iteratively merges the most diminutive trees.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Initialize a forest where each node is a separate tree.</p></li>
<li><p>While there are more than one tree in the forest:
Find the most minor edge that connects two distinct trees.
Merge the two trees into one.</p></li>
<li><p>Continue this process until only one tree remains in the forest.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Circuit Design: Kruskal’s Algorithm is used in designing electrical circuits to connect components cost-efficiently.</p></li>
<li><p>Transportation Networks: It’s employed in designing optimal routes for transportation systems, such as road networks and railways.</p></li>
<li><p>Molecular Biology: Kruskal’s Algorithm is used in computational biology for analyzing genetic sequences and constructing evolutionary trees.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>Kruskal’s algorithm addresses the problem of finding the minimum spanning tree (MST) of a connected, undirected graph. The minimum spanning tree is a subset of the edges of the graph that forms a tree, connecting all the vertices together with the minimum possible total edge weight.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following undirected graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">--</span><span class="mi">1</span><span class="o">--&gt;</span> <span class="mi">1</span> <span class="o">--</span><span class="mi">3</span><span class="o">--&gt;</span> <span class="mi">2</span>
   <span class="o">|</span>           <span class="o">|</span>     <span class="o">|</span>
   <span class="n">v</span>           <span class="n">v</span>     <span class="n">v</span>
   <span class="mi">3</span> <span class="o">---</span><span class="mi">2</span><span class="o">---&gt;</span>  <span class="mi">4</span> <span class="o">--</span><span class="mi">4</span><span class="o">--&gt;</span> <span class="mi">5</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Create a graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Add edge labels</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Kruskal&#39;s algorithm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9780844a1950ac5759b31511fcae7fa1a81df4da94be3889d71436a536da7f79.png" src="_images/9780844a1950ac5759b31511fcae7fa1a81df4da94be3889d71436a536da7f79.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">x_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y_root</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">x_root</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">y_root</span><span class="p">]:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">x_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_root</span>
    <span class="k">elif</span> <span class="n">rank</span><span class="p">[</span><span class="n">x_root</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">y_root</span><span class="p">]:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">y_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_root</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">y_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_root</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">x_root</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">kruskal</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">mst</span> <span class="o">=</span> <span class="p">[]</span>                                <span class="c1"># Initialize minimum spanning tree</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>                              <span class="c1"># List to store edges sorted by weight</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>                             <span class="c1"># Dictionary to store parent of each node</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="p">{}</span>                               <span class="c1"># Dictionary to store rank of each node</span>

    <span class="c1"># Sort edges by weight and initialize parent and rank dictionaries</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># Iterate over sorted edges</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="n">u_parent</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
        <span class="n">v_parent</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># If including this edge does not create a cycle, add it to the minimum spanning tree</span>
        <span class="k">if</span> <span class="n">u_parent</span> <span class="o">!=</span> <span class="n">v_parent</span><span class="p">:</span>
            <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span>
            <span class="n">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">u_parent</span><span class="p">,</span> <span class="n">v_parent</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mst</span>

<span class="c1"># Example graph represented as an adjacency list with weighted edges</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;5&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Perform Kruskal&#39;s algorithm to find the minimum spanning tree</span>
<span class="n">mst_edges</span> <span class="o">=</span> <span class="n">kruskal</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum Spanning Tree Edges:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">mst_edges</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Minimum Spanning Tree Edges:
(&#39;0&#39;, &#39;1&#39;, 1)
(&#39;0&#39;, &#39;3&#39;, 2)
(&#39;3&#39;, &#39;4&#39;, 2)
(&#39;1&#39;, &#39;2&#39;, 3)
(&#39;2&#39;, &#39;5&#39;, 4)
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Find Function</strong>: The <code class="docutils literal notranslate"><span class="pre">find</span></code> function recursively finds the set representative (root) of the given element in the disjoint-set data structure.</p></li>
<li><p><strong>Union Function</strong>: The <code class="docutils literal notranslate"><span class="pre">union</span></code> function performs the union operation in the disjoint-set data structure by rank. It merges two sets based on their ranks to keep the tree height balanced.</p></li>
<li><p><strong>Kruskal’s Algorithm Function</strong>: The <code class="docutils literal notranslate"><span class="pre">kruskal</span></code> function takes the graph represented as an adjacency list as input. It computes and returns the minimum spanning tree of the graph using Kruskal’s algorithm.</p></li>
<li><p><strong>Initialization</strong>: We initialize an empty list <code class="docutils literal notranslate"><span class="pre">mst</span></code> to store the edges of the minimum spanning tree, and lists <code class="docutils literal notranslate"><span class="pre">edges</span></code>, <code class="docutils literal notranslate"><span class="pre">parent</span></code>, and <code class="docutils literal notranslate"><span class="pre">rank</span></code> to store edges sorted by weight, parent of each node, and rank of each node, respectively.</p></li>
<li><p><strong>Sort Edges by Weight</strong>: We sort the edges by weight in non-decreasing order and initialize the parent and rank dictionaries for each node.</p></li>
<li><p><strong>Main Loop</strong>: We iterate over the sorted edges and for each edge, we check if including it in the minimum spanning tree would create a cycle. If not, we add it to the minimum spanning tree and perform the union operation to merge the sets containing the edge endpoints.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list with weighted edges.</p></li>
<li><p><strong>Performing Kruskal’s Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">kruskal</span></code> function with the example graph to compute the minimum spanning tree. The resulting minimum spanning tree edges are printed as output.</p></li>
</ol>
</section>
</section>
<section id="strongly-connected-components-sccs">
<h3><strong>Strongly Connected Components (SCCs)</strong><a class="headerlink" href="#strongly-connected-components-sccs" title="Link to this heading">#</a></h3>
<p>####<strong>Tarjan’s Algorithm</strong></p>
<p><strong>Explanation and Algorithm</strong></p>
<p>Tarjan’s Algorithm is a robust algorithm to find strongly connected components (SCCs) in a directed graph. An SCC is a subset of nodes where every node is reachable from every other node within the subgroup.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Perform a depth-first search (DFS) on the graph.</p></li>
<li><p>Keep track of the order in which nodes are visited and assign each node a unique index and a low-link value.</p></li>
<li><p>Use a stack to keep track of the nodes being explored.</p></li>
<li><p>For each node, update its low-link value based on the lowest index reachable from the node.</p></li>
<li><p>Suppose a node’s low-link value matches its index; pop nodes from the stack until the node is reached again. The popped nodes form an SCC.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Compiler Design: Tarjan’s Algorithm is used in the compiler construction, particularly in the optimization phase for identifying independent components.</p></li>
<li><p>Graph Theory: It’s employed in various graph-related problems that detect strongly connected components.</p></li>
<li><p>Network Analysis: Tarjan’s Algorithm helps identify clusters of highly connected nodes in social networks, biological networks, and other complex systems.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>Tarjan’s algorithm addresses the problem of finding strongly connected components (SCCs) in a directed graph. A strongly connected component is a set of vertices in a directed graph where each vertex is reachable from every other vertex within the same component.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following directed graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">---&gt;</span> <span class="mi">1</span>
   <span class="o">^</span>      <span class="o">|</span>
   <span class="o">|</span>      <span class="o">|</span>
   <span class="mi">3</span> <span class="o">&lt;---</span> <span class="mi">2</span>

</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">tarjan</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">index</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">low_link</span><span class="p">,</span> <span class="n">on_stack</span><span class="p">,</span> <span class="n">sccs</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">on_stack</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">on_stack</span><span class="p">:</span>
                <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">scc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">on_stack</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">scc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">low_link</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="n">on_stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sccs</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># Find strongly connected components using Tarjan&#39;s algorithm</span>
<span class="n">sccs</span> <span class="o">=</span> <span class="n">tarjan</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strongly Connected Components:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Highlight strongly connected components</span>
<span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">scc</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Directed Graph with Strongly Connected Components&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Strongly Connected Components:
</pre></div>
</div>
<img alt="_images/632c878af3f739c3d00496eba04508a38eaa257db09c1b3d1676e4210f14243b.png" src="_images/632c878af3f739c3d00496eba04508a38eaa257db09c1b3d1676e4210f14243b.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">tarjan</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">index</span><span class="p">,</span> <span class="n">stack</span><span class="p">,</span> <span class="n">low_link</span><span class="p">,</span> <span class="n">on_stack</span><span class="p">,</span> <span class="n">sccs</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">on_stack</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">on_stack</span><span class="p">:</span>
                <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">low_link</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">scc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">on_stack</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">scc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">u</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">low_link</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="n">on_stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">low_link</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sccs</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># Find strongly connected components using Tarjan&#39;s algorithm</span>
<span class="n">sccs</span> <span class="o">=</span> <span class="n">tarjan</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strongly Connected Components:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>DFS Function</strong>: The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function performs a depth-first search (DFS) traversal of the graph starting from a given node <code class="docutils literal notranslate"><span class="pre">u</span></code>. It assigns indices and low link values to each node and identifies strongly connected components during the traversal.</p></li>
<li><p><strong>Main Algorithm</strong>: The main algorithm initializes necessary variables and iterates through each node in the graph. For each unvisited node, it invokes the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function to identify strongly connected components.</p></li>
<li><p><strong>Index and Low Link Values</strong>: The <code class="docutils literal notranslate"><span class="pre">index</span></code> variable keeps track of the order of node discovery during the DFS traversal. The <code class="docutils literal notranslate"><span class="pre">low_link</span></code> dictionary stores the low link values for each node, which represent the smallest index of any node known to be reachable from the current node, including itself.</p></li>
<li><p><strong>Stack and On Stack Set</strong>: The <code class="docutils literal notranslate"><span class="pre">stack</span></code> data structure maintains the nodes visited in the current DFS traversal path. The <code class="docutils literal notranslate"><span class="pre">on_stack</span></code> set keeps track of nodes currently on the stack.</p></li>
<li><p><strong>Strongly Connected Components</strong>: When a node’s low link value equals its index, it indicates the start of a strongly connected component. The algorithm pops nodes from the stack until reaching the starting node of the component, collecting the nodes into the <code class="docutils literal notranslate"><span class="pre">sccs</span></code> list.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list. The graph has a cycle and a backward edge, resulting in two strongly connected components.</p></li>
<li><p><strong>Performing Tarjan’s Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">tarjan</span></code> function with the example graph to find strongly connected components. The resulting strongly connected components are printed as output.</p></li>
</ol>
<section id="kosarajus-algorithm">
<h4><strong>Kosaraju’s Algorithm</strong><a class="headerlink" href="#kosarajus-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>Kosaraju’s Algorithm is another efficient algorithm for finding strongly connected components in a directed graph. It operates in two passes: the first pass involves a DFS to determine the order of node traversal, and the second pass identifies the SCCs.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Perform a depth-first search (DFS) on the reverse graph to get the finishing times of nodes.</p></li>
<li><p>In the original chart, traverse nodes in reverse finishing time order and perform DFS to identify SCCs.</p></li>
</ol>
<p><strong>Applications and Use Cases</strong></p>
<ul class="simple">
<li><p>Path Finding: Kosaraju’s Algorithm can be applied in GPS systems to find the optimal route between locations.</p></li>
<li><p>Natural Language Processing: It’s used in various applications like sentiment analysis, where understanding text structure is crucial.</p></li>
<li><p>Database Design: Kosaraju’s Algorithm aids in optimizing database queries by identifying dependencies between tables.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>Kosaraju’s algorithm is used to find all strongly connected components (SCCs) in a directed graph. An SCC is a subset of vertices in a graph where every vertex is reachable from every other vertex within the same component.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following directed graph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="mi">0</span> <span class="o">---&gt;</span> <span class="mi">1</span>
   <span class="o">|</span>      <span class="o">^</span>
   <span class="o">|</span>      <span class="o">|</span>
   <span class="n">v</span>      <span class="o">|</span>
   <span class="mi">3</span> <span class="o">&lt;---</span> <span class="mi">2</span>

</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">kosaraju</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs_reverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">):</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">scc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph_reverse</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs_reverse</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">)</span>

    <span class="c1"># First DFS to fill the stack with vertices in order of their finishing times</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

    <span class="c1"># Transpose the graph</span>
    <span class="n">graph_reverse</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">graph_reverse</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="c1"># Second DFS to find SCCs</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">scc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dfs_reverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">)</span>
            <span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sccs</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># Find strongly connected components using Kosaraju&#39;s algorithm</span>
<span class="n">sccs</span> <span class="o">=</span> <span class="n">kosaraju</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strongly Connected Components:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Highlight strongly connected components</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">scc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sccs</span><span class="p">):</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">nodelist</span><span class="o">=</span><span class="n">scc</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;SCC </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Directed Graph with Strongly Connected Components&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Strongly Connected Components:
[&#39;0&#39;, &#39;3&#39;, &#39;2&#39;, &#39;1&#39;]
</pre></div>
</div>
<img alt="_images/dcec33a74a0c4c1932812d712297bb336cf2a893bf23d5afdf4d96f5b472795b.png" src="_images/dcec33a74a0c4c1932812d712297bb336cf2a893bf23d5afdf4d96f5b472795b.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">kosaraju</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dfs_reverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">):</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">scc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph_reverse</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs_reverse</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">)</span>

    <span class="c1"># First DFS to fill the stack with vertices in order of their finishing times</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

    <span class="c1"># Transpose the graph</span>
    <span class="n">graph_reverse</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">graph_reverse</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="c1"># Second DFS to find SCCs</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">scc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dfs_reverse</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">scc</span><span class="p">)</span>
            <span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sccs</span>

<span class="c1"># Example graph represented as an adjacency list</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;1&#39;</span><span class="p">],</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;2&#39;</span><span class="p">],</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># Find strongly connected components using Kosaraju&#39;s algorithm</span>
<span class="n">sccs</span> <span class="o">=</span> <span class="n">kosaraju</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Strongly Connected Components:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">scc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>DFS Functions</strong>: The first DFS function (<code class="docutils literal notranslate"><span class="pre">dfs</span></code>) is used to fill the stack with vertices in order of their finishing times. The second DFS function (<code class="docutils literal notranslate"><span class="pre">dfs_reverse</span></code>) is used to find strongly connected components (SCCs) starting from a given vertex.</p></li>
<li><p><strong>First DFS</strong>: We perform a DFS traversal on the graph to fill the stack with vertices. The order in which vertices are added to the stack represents their finishing times in the reverse topological order.</p></li>
<li><p><strong>Graph Transpose</strong>: We transpose the graph to obtain the reverse of the original graph. This is done by reversing the direction of all edges in the graph.</p></li>
<li><p><strong>Second DFS</strong>: We perform another DFS traversal on the transposed graph starting from vertices in the order given by the stack. This allows us to identify strongly connected components efficiently.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example graph represented as an adjacency list. The graph has a cycle and a backward edge, resulting in two strongly connected components.</p></li>
<li><p><strong>Performing Kosaraju’s Algorithm</strong>: Finally, we call the <code class="docutils literal notranslate"><span class="pre">kosaraju</span></code> function with the example graph to find strongly connected components. The resulting strongly connected components are printed as output.</p></li>
</ol>
</section>
</section>
<section id="flow-algorithms">
<h3><strong>Flow Algorithms</strong><a class="headerlink" href="#flow-algorithms" title="Link to this heading">#</a></h3>
<section id="ford-fulkerson-algorithm-for-maximum-flow">
<h4><strong>Ford-Fulkerson Algorithm for Maximum Flow</strong><a class="headerlink" href="#ford-fulkerson-algorithm-for-maximum-flow" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>The Ford-Fulkerson Algorithm is a fundamental algorithm for finding the maximum flow in a flow network. It operates by iteratively augmenting paths from the source to the sink until no more augmenting courses can be found.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Start with an initial flow of zero.</p></li>
<li><p>Find an augmenting path from the source to the sink using techniques like Breadth-First Search (BFS) or Depth-First Search (DFS).</p></li>
<li><p>Determine the maximum additional flow that can be pushed through this path.</p></li>
<li><p>Update the flow along the path.</p></li>
<li><p>Repeat steps 2–4 until no more augmenting paths can be found.</p></li>
</ol>
<p><strong>Applications in Network Flows</strong></p>
<ul class="simple">
<li><p>Transportation Networks: It’s used in optimizing transportation networks to maximize the flow of goods, ensuring efficient logistics.</p></li>
<li><p>Telecommunications: Ford-Fulkerson is employed in data routing for maximizing data transmission in communication networks.</p></li>
<li><p>Water Distribution Systems: It helps efficiently distribute water in pipelines to meet demand while minimizing waste.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>The Ford-Fulkerson algorithm is used to find the maximum flow in a flow network, which is a directed graph where each edge has a capacity and represents a flow between two vertices.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following flow network:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>         <span class="mi">1</span>
   <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-------&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">|</span> \          <span class="o">|</span> \
 <span class="mi">5</span>  <span class="o">|</span>  \<span class="mi">4</span>       <span class="mi">4</span><span class="o">|</span>  \<span class="mi">5</span>
    <span class="o">|</span>   \        <span class="o">|</span>   \
   <span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="o">|</span>    <span class="o">|</span>       <span class="o">|</span>    <span class="o">|</span>
    <span class="n">v</span>    <span class="o">|</span><span class="mi">1</span>      <span class="n">v</span>    <span class="o">|</span>
   <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;---------</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
         <span class="mi">3</span>

</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">class</span> <span class="nc">FordFulkerson</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">sink</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="ow">and</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flow_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">flow_path</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">flow_path</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">max_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_flow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">while</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">path</span><span class="p">)</span>
            <span class="n">max_flow</span> <span class="o">+=</span> <span class="n">flow</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">flow</span>
                <span class="c1"># Check if the reverse edge exists before updating its capacity</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="ow">and</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">flow</span>  <span class="c1"># Residual capacity</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">flow</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">max_flow</span>

<span class="c1"># Example graph represented as an adjacency list with capacities</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1"># Create Ford-Fulkerson object with the graph, source, and sink</span>
<span class="n">ff</span> <span class="o">=</span> <span class="n">FordFulkerson</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>

<span class="c1"># Find the maximum flow using Ford-Fulkerson algorithm</span>
<span class="n">max_flow</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">max_flow</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum Flow:&quot;</span><span class="p">,</span> <span class="n">max_flow</span><span class="p">)</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>

<span class="c1"># Create a mapping for edge labels (capacities)</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Flow Network with Maximum Flow&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum Flow: 10
</pre></div>
</div>
<img alt="_images/b8fd4b3106e22261838c0d6d034d694ea0dcf405b8189b00751a1352f25cd363.png" src="_images/b8fd4b3106e22261838c0d6d034d694ea0dcf405b8189b00751a1352f25cd363.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FordFulkerson</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">sink</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="ow">and</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flow_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)])</span>
                <span class="k">if</span> <span class="n">flow_path</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">flow_path</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">max_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_flow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">while</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">path</span><span class="p">)</span>
            <span class="n">max_flow</span> <span class="o">+=</span> <span class="n">flow</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">flow</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="ow">and</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>  <span class="c1"># Check if reverse edge exists</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="n">flow</span>  <span class="c1"># Update residual capacity</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{})[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">flow</span>  <span class="c1"># Add reverse edge if it doesn&#39;t exist</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">max_flow</span>

<span class="c1"># Example graph represented as an adjacency list with capacities</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1"># Create Ford-Fulkerson object with the graph, source, and sink</span>
<span class="n">ff</span> <span class="o">=</span> <span class="n">FordFulkerson</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>

<span class="c1"># Find the maximum flow using Ford-Fulkerson algorithm</span>
<span class="n">max_flow</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">max_flow</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum Flow:&quot;</span><span class="p">,</span> <span class="n">max_flow</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum Flow: 10
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ol class="arabic simple">
<li><p><strong>Ford-Fulkerson Class</strong>: The <code class="docutils literal notranslate"><span class="pre">FordFulkerson</span></code> class encapsulates the Ford-Fulkerson algorithm implementation. It takes the graph, source node, and sink node as input.</p></li>
<li><p><strong>Depth-First Search (DFS)</strong>: The <code class="docutils literal notranslate"><span class="pre">dfs</span></code> method performs a depth-first search (DFS) traversal to find an augmenting path from the source to the sink with positive capacities.</p></li>
<li><p><strong>Max Flow Calculation</strong>: The <code class="docutils literal notranslate"><span class="pre">max_flow</span></code> method iteratively finds augmenting paths using DFS and updates the flow in the graph until no more augmenting paths can be found.</p></li>
<li><p><strong>Example Graph</strong>: We provide an example flow network represented as an adjacency list with capacities. The source node is denoted by ‘s’, and the sink node is denoted by ‘t’.</p></li>
<li><p><strong>Performing Ford-Fulkerson Algorithm</strong>: Finally, we create a <code class="docutils literal notranslate"><span class="pre">FordFulkerson</span></code> object with the example graph, source, and sink nodes, and then find the maximum flow using the <code class="docutils literal notranslate"><span class="pre">max_flow</span></code> method. The resulting maximum flow is printed as output.</p></li>
</ol>
</section>
<section id="edmonds-karp-algorithm">
<h4><strong>Edmonds-Karp Algorithm</strong><a class="headerlink" href="#edmonds-karp-algorithm" title="Link to this heading">#</a></h4>
<p><strong>Explanation and Algorithm</strong></p>
<p>The Edmonds-Karp Algorithm is a specific implementation of the Ford-Fulkerson Algorithm that uses Breadth-First Search (BFS) to find augmenting paths. This ensures that the shortest augmenting path is chosen at each iteration.</p>
<p><strong>Algorithm:</strong></p>
<ol class="arabic simple">
<li><p>Apply BFS to find the shortest augmenting path from source to sink.</p></li>
<li><p>Determine the maximum additional flow that can be pushed through this path.</p></li>
<li><p>Update the flow along the path.</p></li>
<li><p>Repeat steps 1–3 until no more augmenting paths can be found.</p></li>
</ol>
<p><strong>Applications in Network Flows</strong></p>
<ul class="simple">
<li><p>Max-Flow Min-Cut Theorem: The Edmonds-Karp algorithm is foundational in proving the Max-Flow Min-Cut theorem, which states that the maximum flow in a network is equal to the minimum capacity of a cut in the network.</p></li>
<li><p>Image Segmentation: It’s employed in computer vision for segmenting images based on region connectivity.</p></li>
<li><p>Network Design: Edmonds-Karp helps design cost-effective networks with optimal data flow.</p></li>
</ul>
<p><strong>Description:</strong></p>
<p>The Edmonds-Karp algorithm is used to find the maximum flow in a flow network, which is a directed graph where each edge has a capacity and represents a flow between two vertices.</p>
<p><strong>Graph:</strong></p>
<p>Consider the following flow network:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>         <span class="mi">1</span>
   <span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-------&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">|</span> \          <span class="o">|</span> \
 <span class="mi">5</span>  <span class="o">|</span>  \<span class="mi">4</span>       <span class="mi">4</span><span class="o">|</span>  \<span class="mi">5</span>
    <span class="o">|</span>   \        <span class="o">|</span>   \
   <span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="p">(</span><span class="mi">3</span><span class="p">)</span>     <span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="o">|</span>    <span class="o">|</span>       <span class="o">|</span>    <span class="o">|</span>
    <span class="n">v</span>    <span class="o">|</span><span class="mi">1</span>      <span class="n">v</span>    <span class="o">|</span>
   <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;---------</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
         <span class="mi">3</span>
</pre></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Create a directed graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

<span class="c1"># Add nodes and edges to the graph</span>
<span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>

<span class="c1"># Create a mapping for edge labels (capacities)</span>
<span class="n">edge_labels</span> <span class="o">=</span> <span class="p">{(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>

<span class="c1"># Draw the graph</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">node_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">node_color</span><span class="o">=</span><span class="s1">&#39;lightblue&#39;</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">font_weight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">edge_labels</span><span class="o">=</span><span class="n">edge_labels</span><span class="p">)</span>

<span class="c1"># Show the graph</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Flow Network&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/1aedc7a6b99e854d489179b9b423f356653a82d8c2dd75052822f55c38bf8a32.png" src="_images/1aedc7a6b99e854d489179b9b423f356653a82d8c2dd75052822f55c38bf8a32.png" />
</div>
</div>
<p><strong>Code:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">EdmondsKarp</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">sink</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sink</span> <span class="o">=</span> <span class="n">sink</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">capacity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="ow">and</span> <span class="n">capacity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">max_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">max_flow</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">}</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
            <span class="n">path_flow</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span>
            <span class="k">while</span> <span class="n">s</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="n">path_flow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_flow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">s</span><span class="p">]][</span><span class="n">s</span><span class="p">])</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">max_flow</span> <span class="o">+=</span> <span class="n">path_flow</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sink</span>
            <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">-=</span> <span class="n">path_flow</span>
                <span class="c1"># Ensure that both forward and reverse edges are properly updated</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">path_flow</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">max_flow</span>

<span class="c1"># Example graph represented as an adjacency list with capacities</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">},</span>
    <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="s1">&#39;4&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;6&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1"># Create Edmonds-Karp object with the graph, source, and sink</span>
<span class="n">ek</span> <span class="o">=</span> <span class="n">EdmondsKarp</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">)</span>

<span class="c1"># Find the maximum flow using Edmonds-Karp algorithm</span>
<span class="n">max_flow</span> <span class="o">=</span> <span class="n">ek</span><span class="o">.</span><span class="n">max_flow</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum Flow:&quot;</span><span class="p">,</span> <span class="n">max_flow</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum Flow: 10
</pre></div>
</div>
</div>
</div>
<p><strong>Explanation:</strong></p>
<ul class="simple">
<li><p><strong>Problem Description</strong>: The Edmonds-Karp algorithm finds the maximum flow in a flow network, represented by a directed graph where each edge has a capacity.</p></li>
<li><p><strong>Graph</strong>: The flow network graph is represented using an adjacency list with capacities between nodes.</p></li>
<li><p><strong>Plot</strong>: The plot visualizes the flow network graph with node labels and edge capacities.</p></li>
<li><p><strong>Solution Code</strong>: The EdmondsKarp class implements the Edmonds-Karp algorithm to find the maximum flow in the flow network graph.</p></li>
<li><p><strong>Explanation</strong>: The algorithm uses breadth-first search (BFS) to find augmenting paths from the source to the sink in the graph. It updates the flow along the augmenting paths until no more augmenting paths can be found, resulting in the maximum flow.</p></li>
</ul>
</section>
</section>
</section>
<section id="the-applications-of-graph-traversal-in-computer-science">
<h2><strong>The Applications of Graph Traversal in Computer Science</strong><a class="headerlink" href="#the-applications-of-graph-traversal-in-computer-science" title="Link to this heading">#</a></h2>
<p>Graph traversal is a fundamental concept in computer science, finding a broad spectrum of applications. This integral algorithm finds its applications in various domains ranging from networking to relativistic physics to artificial intelligence, and beyond. Understanding graph traversal is more than an academic exercise; it is a practical tool that addresses real-world computational problems, making it a vital topic to learn and understand.</p>
<section id="real-world-applications-of-graph-traversal">
<h3><strong>Real-World Applications of Graph Traversal</strong><a class="headerlink" href="#real-world-applications-of-graph-traversal" title="Link to this heading">#</a></h3>
<p>Diving deep into the applications of graph traversal in real-world scenarios reveals its prominence. One of its prominent applications is in Network Routing. Network routers make use of graph traversal algorithms like Dijkstra’s to discover the most expedient path for data packets between two network nodes. This routing essentially forms the backbone of the Internet and every local network.</p>
<p>In the day-to-day operation of the web, routers use algorithms akin to Breadth-First Search (BFS) and Depth-First Search (DFS) to handle the non-static nature of networks, such as when a router becomes unavailable and a new route needs to be swiftly found. These algorithms help efficiently navigate such huge networks.</p>
<p>Apart from networking, another common application of graph traversal algorithms is in the domain of web crawling. Search engines like Google utilise graph traversal algorithms to navigate the billions of interconnected websites to index the web. Essentially, a web crawler starts at one page (URL), explores all its linked pages, and continues this process infinitely to build a significant index of the Web. This process can be compared to a BFS or DFS search where the URLs represent the vertices and the hyperlinks represent the edges.</p>
</section>
<section id="how-graph-traversal-is-changing-the-tech-industry">
<h3><strong>How Graph Traversal is Changing the Tech Industry</strong><a class="headerlink" href="#how-graph-traversal-is-changing-the-tech-industry" title="Link to this heading">#</a></h3>
<p>Graph traversal algorithms underpin many advanced operations in the tech industry today. They are particularly impactful in Artificial Intelligence (AI), playing a major role in search algorithms, route planning, and decision making.</p>
<p>For example, consider autonomous vehicles. They extensively use graph theory for route planning. They apply Dijkstra’s algorithm or A* Search to graph data representing the real world’s grid road structure to find the most effective route.</p>
<p>Additionally, commercial games have grown in complexity by leaps and bounds, with many relying heavily on graph traversal algorithms. Games like World of Warcraft or Dragon Age utilise A* Search to assist Non-Player Characters (NPCs) in navigating complex, obstacle-filled maps. These algorithms calculate the shortest path from the NPC’s location to its target destination, considering various data such as terrain, threats and objectives.</p>
<p>In the data science industry, graph traversal applications exist in the detection of community structure in networks. Social media platforms, for instance, utilise graph traversal algorithms to identify tightly-knit groups of users. This information can be instrumental for targeted advertising, recommendations, and combating misinformation or span.</p>
<p>Furthermore, algorithms like DFS can be used to determine connectivity in a network, in applications like tracing how malware or a virus can spread between computers. The operation of Bitcoin’s Blockchain network itself is an example of distributed graph-based data structures that work using advanced graph traversal strategies.</p>
<p>So, it’s evident that graph traversal algorithms are paving a dramatic impact in the tech industry, breaking new ground for innovative technologies and transforming various fields from gaming, networking, to AI and data science.</p>
</section>
</section>
<section id="tips-for-solving-problems-with-graph-traversal-algorithms">
<h2><strong>Tips for Solving Problems with Graph Traversal Algorithms</strong><a class="headerlink" href="#tips-for-solving-problems-with-graph-traversal-algorithms" title="Link to this heading">#</a></h2>
<p>Graph traversal problems can seem daunting at first. However, with a solid understanding of the underlying principles, the right approach, and a lot of practice, you can master these problems. Here are a few tips:</p>
<ul class="simple">
<li><p>Understand the problem: Determine whether it’s a graph traversal problem. Sometimes, it might not be all that apparent.</p></li>
<li><p>Identify the right traversal algorithm: Consider the nature of the graph (e.g., weighted, directed), the nature of the problem (e.g., shortest path, cycle detection), and choose between BFS, DFS, Dijkstra’s, A* Search or other relevant algorithms accordingly.</p></li>
<li><p>Make sure to visit each node only once: While visiting each node, mark it as ‘visited’ to ensure you don’t visit the same node more than once.</p></li>
<li><p>Understand recursion: If you’re using DFS, ensure you understand how recursion works as it’s a recursively defined algorithm.</p></li>
<li><p>Choose the right data structure: Depending on the problem requirements and the chosen traversal algorithm, select an appropriate data structure to efficiently store and manipulate graph nodes and edges. For example, use queues for BFS and stacks or recursion for DFS.</p></li>
<li><p>Handle graph representations: Be comfortable working with different graph representations such as adjacency matrices, adjacency lists, or edge lists. Understanding the strengths and weaknesses of each representation can help in optimizing traversal algorithms.</p></li>
<li><p>Consider edge cases: Be mindful of edge cases and special conditions in the problem statement. Test your implementation with various input sizes, including small, medium, and large graphs, to ensure its correctness and efficiency.</p></li>
<li><p>Optimize time and space complexity: Aim to optimize both time and space complexity of your traversal algorithm. Look for opportunities to reduce redundant computations, minimize memory usage, and improve overall efficiency.</p></li>
<li><p>Visualize the graph: Visualizing the graph and the traversal process can aid in understanding and debugging your implementation. Use graph visualization tools or draw diagrams to visualize the graph structure and traversal paths.</p></li>
<li><p>Understand algorithm limitations: Be aware of the limitations and assumptions of the chosen traversal algorithm. For example, BFS may not be suitable for graphs with cycles, and DFS may encounter stack overflow errors on deep recursive calls.</p></li>
<li><p>Practice: Abstract problems in computer science, especially those related to data structures and algorithms, are best learned through practice. Practice a variety of problems on different online platforms.</p></li>
<li><p>Learn from others: Engage with the community, participate in online forums, and study solutions provided by others. Analyze different approaches and learn from their strengths and weaknesses to improve your problem-solving skills.</p></li>
</ul>
<p>Remember, understanding the underlying concept is key to cracking graph traversal problems, and practice is essential to become adept at using these concepts.</p>
</section>
<section id="leetcode-problems-related-to-graph-traversals">
<h2><strong>Leetcode Problems related to Graph Traversals</strong><a class="headerlink" href="#leetcode-problems-related-to-graph-traversals" title="Link to this heading">#</a></h2>
<section id="problem-1-number-of-provincies">
<h3><strong>Problem #1 Number of Provincies</strong><a class="headerlink" href="#problem-1-number-of-provincies" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/number-of-provinces/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.</p>
<p>A province is a group of directly or indirectly connected cities and no other cities outside of the group.</p>
<p>You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.</p>
<p>Return the total number of provinces.</p>
<p><strong>Example:</strong></p>
<p><img alt="Pr#1" src="https://assets.leetcode.com/users/images/4d3f201e-7106-4721-a990-321f335383a9_1691929198.4933982.png" /></p>
<p><strong>Explanation:</strong></p>
<p>We can solve this problem with the help of BFS/DFS. So let’s think about it:
We can maintain a visited array which represents all the nodes. Mark all the nodes as 0(Unvisited).</p>
<p>Then transverse all the nodes and if that node is unvisited, then consider it as a seprate graph(Provinces), and consider that node as a starting node and traverse that graph using DFS/BFS.</p>
<p>DFS/BFS will help to mark all the nodes in a graph as visited.
At last mantain a counter and count number of time DFS/BFS is called.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">findCircleNum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">isConnected</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isConnected</span><span class="p">)</span>

        <span class="c1"># converting adjacent matrix into adjacent list</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">isConnected</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># creating visited array and counter</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span>

<span class="c1"># Define the input adjacency matrix</span>
<span class="n">isConnected</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Call the findCircleNum method and print the result</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">findCircleNum</span><span class="p">(</span><span class="n">isConnected</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of connected components:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of connected components: 2
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-2-rotting-oranges">
<h3><strong>Problem #2 Rotting Oranges</strong><a class="headerlink" href="#problem-2-rotting-oranges" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/rotting-oranges/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an m x n grid where each cell can have one of three values:</p>
<p>0 representing an empty cell,
1 representing a fresh orange, or
2 representing a rotten orange.</p>
<p>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.
Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.</p>
<p><strong>Explanation:</strong></p>
<p>According to the problem statement, one rotten orange can cause 4 of its neighbors to rot, and those 4 neighbors, in the second iteration, can then cause their immediate neighbors to rot. This pattern is very similar to BFS. Let’s discuss how we can solve this problem using BFS.</p>
<p>Steps:</p>
<ol class="arabic simple">
<li><p>First, create a queue to store all the rotten oranges.</p></li>
<li><p>While the queue is not empty, pick a rotten orange from the queue and check in all four directions. If you find a fresh orange, make it rotten and add it to the queue.</p></li>
<li><p>If you rot some oranges during this iteration, increment the day count.</p></li>
<li><p>Repeat this process until queue is empty.</p></li>
</ol>
<p>To check whether we have been able to rot all the oranges in the end, maintain a count of the total number of oranges initially and a count of the total number of rotten oranges after the BFS (Breadth-First Search).
If both counts are equal, it indicates that we have been able to rot all the oranges.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">orangesRotting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="c1"># Define utils arrays to navigate in all four directions</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">totalOrg</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># Building a queue for all the starting points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">totalOrg</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="n">k</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

                <span class="c1"># Technique to traverse in all four directions</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># If orange is fresh, make it rotten and push it to queue</span>
                    <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">q</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># If count of rotten oranges is equal to total oranges then return time</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="n">totalOrg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Example grid</span>
<span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Call the orangesRotting method and print the result</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">orangesRotting</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time taken for all oranges to rot:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Time taken for all oranges to rot: 4
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-3-flood-fill">
<h3><strong>Problem #3 Flood Fill</strong><a class="headerlink" href="#problem-3-flood-fill" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/flood-fill/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.</p>
<p>You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].
To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.</p>
<p>Return the modified image after performing the flood fill.</p>
<p><strong>Explanation:</strong></p>
<p>If you are approaching this problem after solving the “Rotten Oranges” problem, it’s likely that you are considering solving it using BFS.
However, there’s an important distinction between the two. In the Rotten Oranges problem, the objective is to determine the total time required to rot all the oranges, which imposes specific constraints.</p>
<p>In this problem, however, such constraints are absent. This leads us to the conclusion that we can employ either BFS or DFS.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Define utils arrays to navigate in all four directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initColor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span>

        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="c1"># Technique to traverse in all four directions</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initColor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initColor</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">floodFill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="c1"># Building some global variable for code simplicity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfsAns</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">image</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[:]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">image</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initColor</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">sr</span><span class="p">][</span><span class="n">sc</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newColor</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># Answer using BFS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)</span>

        <span class="c1"># Answer using DFS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bfsAns</span>  <span class="c1"># Return dfsAns in case of dfs</span>

<span class="c1"># Example usage:</span>
<span class="n">image</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">sr</span><span class="p">,</span> <span class="n">sc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">color</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">floodFill</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Result after flood fill:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Result after flood fill:
[2, 2, 2]
[2, 2, 0]
[2, 0, 1]
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-4-surrounded-regions">
<h3><strong>Problem #4 Surrounded Regions</strong><a class="headerlink" href="#problem-4-surrounded-regions" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/surrounded-regions/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’.
A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p><strong>Explanation:</strong></p>
<p>Upon careful analysis of the problem, it becomes evident that the boundary elements of the matrix cannot be encompassed by ‘X’. As a result, our traversal should initiate from these boundary elements.
We need to identify all the interconnected ‘O’ through this traversal process. Once the traversal is complete, the remaining ‘O’ that have not been connected to the boundaries can be replaced with ‘X’ .
This process will effectively capture and transform the regions enclosed by ‘X’ into the desired outcome.
We can use both BFS/DFS for this problem.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create a visited array and initialize it with 0.</p></li>
<li><p>Do the boundry traversal of the matrix given.</p></li>
<li><p>If you find ‘O’ then call DFS Funtion.
<em>DFS Funtion will run through all the neighboring ‘O’ in all four direction and mark them as visited.</em></p></li>
<li><p>At last we can calculate our answer based on visited array as all the 1 is ‘O’ and remaining are ‘X’ .</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">):</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>

        <span class="c1"># boundary traversal column</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">)</span>

        <span class="c1"># boundary traversal row</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;O&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">board</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;X&#39;</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-5-number-of-enclaves">
<h3><strong>Problem #5 Number of Enclaves</strong><a class="headerlink" href="#problem-5-number-of-enclaves" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/number-of-enclaves/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an m x n binary matrix grid, where 0 represents a sea cell and 1 represents a land cell.
A move consists of walking from one land cell to another adjacent (4-directionally) land cell or walking off the boundary of the grid.
Return the number of land cells in grid for which we cannot walk off the boundary of the grid in any number of moves.</p>
<p><strong>Explanation:</strong></p>
<p>This problem is very similar to surrounded region. We can follow the very same approch that we followed in surrounded region problem.</p>
<p><strong>DFS Solution:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numEnclaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>

        <span class="c1"># boundary traversal column</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="c1"># boundary traversal row</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ans</span>
</pre></div>
</div>
</div>
</div>
<p><strong>BFS Solution</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="n">vis</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">vis</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numEnclaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)]</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># boundary traversal column</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># boundary traversal row</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vis</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">vis</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">ny</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="ow">or</span> <span class="n">ny</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">vis</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>

        <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ans</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">ans</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-6-is-graph-bipartite">
<h3><strong>Problem #6 Is Graph Bipartite?</strong><a class="headerlink" href="#problem-6-is-graph-bipartite" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/is-graph-bipartite/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:</p>
<p>There are no self-edges (graph[u] does not contain u).
There are no parallel edges (graph[u] does not contain duplicate values).
If v is in graph[u], then u is in graph[v] (the graph is undirected).
The graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.
A graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.
Return true if and only if it is bipartite.</p>
<p><strong>Explanation:</strong></p>
<p>A bipartite graph is a graph where nodes can be separated into two distinct sets, ensuring that neighboring nodes have different colors.
Linear graphs are inherently bipartite, and graphs with even cycles are always guaranteed to be bipartite.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create a visited array which can store different value.
-1 for unvisited.</p></li>
</ol>
<p>0 for first colour.</p>
<p>1 for second colour.</p>
<ol class="arabic simple" start="2">
<li><p>Do DFS traversal on graph for ever unvisited node we will inititate a dfs with initial color as 0.</p></li>
<li><p>At any moment if we get a node which is already coloured with the same colour of current node we will return false.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">color</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">color</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="ow">not</span> <span class="n">col</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">isBipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-7-number-of-islands">
<h3><strong>Problem #7 Number of Islands</strong><a class="headerlink" href="#problem-7-number-of-islands" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/number-of-islands/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> 2D binary grid <code class="docutils literal notranslate"><span class="pre">grid</span></code>, representing a map where <code class="docutils literal notranslate"><span class="pre">'1'</span></code>s represent land and <code class="docutils literal notranslate"><span class="pre">'0'</span></code>s represent water. Your task is to count the number of islands in the grid. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.</p>
<p><strong>Example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Example</span> <span class="mi">1</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">1</span>

<span class="n">Example</span> <span class="mi">2</span><span class="p">:</span>

<span class="n">Input</span><span class="p">:</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">],</span>
  <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;0&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="s2">&quot;1&quot;</span><span class="p">]</span>
<span class="p">]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">3</span>
</pre></div>
</div>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">==</span> <span class="pre">grid.length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">grid[i].length</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">300</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">grid[i][j]</span></code> is <code class="docutils literal notranslate"><span class="pre">'0'</span></code> or <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p></li>
</ul>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can use Depth-First Search (DFS) or Breadth-First Search (BFS) algorithms. We’ll iterate through each cell of the grid, and whenever we encounter a land cell (i.e., <code class="docutils literal notranslate"><span class="pre">'1'</span></code>), we’ll perform a DFS or BFS to explore and mark all adjacent land cells belonging to the same island.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Initialize a variable <code class="docutils literal notranslate"><span class="pre">count</span></code> to store the number of islands.</p></li>
<li><p>Iterate through each cell <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> in the grid.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">grid[i][j]</span> <span class="pre">==</span> <span class="pre">'1'</span></code>, perform DFS or BFS to mark all connected land cells and increment <code class="docutils literal notranslate"><span class="pre">count</span></code> by 1.</p></li>
<li><p>Continue until all cells are visited.</p></li>
<li><p>Return the <code class="docutils literal notranslate"><span class="pre">count</span></code> of islands.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">numIslands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span>  <span class="c1"># Mark current cell as visited</span>
            <span class="c1"># Explore adjacent land cells</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Increment count for each new island</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>   <span class="c1"># Explore and mark all connected land cells</span>
        <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-8-word-ladder">
<h3><strong>Problem #8 Word Ladder</strong><a class="headerlink" href="#problem-8-word-ladder" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/word-ladder/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given a start word <code class="docutils literal notranslate"><span class="pre">beginWord</span></code>, an end word <code class="docutils literal notranslate"><span class="pre">endWord</span></code>, and a dictionary <code class="docutils literal notranslate"><span class="pre">wordList</span></code>, find the length of the shortest transformation sequence from <code class="docutils literal notranslate"><span class="pre">beginWord</span></code> to <code class="docutils literal notranslate"><span class="pre">endWord</span></code>, where:</p>
<ul class="simple">
<li><p>Only one letter can be changed at a time.</p></li>
<li><p>Each transformed word must exist in the word list. Note that <code class="docutils literal notranslate"><span class="pre">beginWord</span></code> does not need to be in <code class="docutils literal notranslate"><span class="pre">wordList</span></code>.</p></li>
<li><p>Return 0 if there is no such transformation sequence.</p></li>
</ul>
<p><strong>Explanation:</strong></p>
<p>The problem requires finding the shortest transformation sequence from <code class="docutils literal notranslate"><span class="pre">beginWord</span></code> to <code class="docutils literal notranslate"><span class="pre">endWord</span></code> while ensuring each intermediate word is present in the given <code class="docutils literal notranslate"><span class="pre">wordList</span></code>. This problem can be effectively solved using a breadth-first search (BFS) approach.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create a set <code class="docutils literal notranslate"><span class="pre">wordSet</span></code> from <code class="docutils literal notranslate"><span class="pre">wordList</span></code> for efficient word lookup.</p></li>
<li><p>Check if <code class="docutils literal notranslate"><span class="pre">endWord</span></code> is not in <code class="docutils literal notranslate"><span class="pre">wordSet</span></code>. If not, return 0 as no transformation sequence is possible.</p></li>
<li><p>Initialize a queue with <code class="docutils literal notranslate"><span class="pre">(beginWord,</span> <span class="pre">1)</span></code> to store the current word and its level in the BFS traversal.</p></li>
<li><p>Create a set <code class="docutils literal notranslate"><span class="pre">visited</span></code> to keep track of visited words and add <code class="docutils literal notranslate"><span class="pre">beginWord</span></code> to it.</p></li>
<li><p>While the queue is not empty, pop the current word and its level.</p></li>
<li><p>Generate all possible transformations of the current word by replacing each character with every lowercase letter from ‘a’ to ‘z’.</p></li>
<li><p>For each transformed word:</p>
<ul class="simple">
<li><p>If it exists in <code class="docutils literal notranslate"><span class="pre">wordSet</span></code> and has not been visited before, add it to the queue along with its level incremented by 1 and mark it as visited.</p></li>
<li><p>Continue this process until <code class="docutils literal notranslate"><span class="pre">endWord</span></code> is reached or all possible transformations are exhausted.</p></li>
</ul>
</li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">endWord</span></code> is reached, return its level. Otherwise, return 0 to indicate that no transformation sequence exists.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">ladderLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beginWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">endWord</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">wordList</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">wordSet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endWord</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wordSet</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">beginWord</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>  <span class="c1"># Initialize queue with beginWord and its level</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">beginWord</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">word</span><span class="p">,</span> <span class="n">level</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">word</span> <span class="o">==</span> <span class="n">endWord</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">level</span>  <span class="c1"># Return level if endWord is reached</span>

            <span class="c1"># Generate all possible transformations of the current word</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;abcdefghijklmnopqrstuvwxyz&#39;</span><span class="p">:</span>
                    <span class="n">next_word</span> <span class="o">=</span> <span class="n">word</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">char</span> <span class="o">+</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">next_word</span> <span class="ow">in</span> <span class="n">wordSet</span> <span class="ow">and</span> <span class="n">next_word</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">next_word</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_word</span><span class="p">)</span>

        <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># If no transformation sequence exists</span>

<span class="c1"># Example usage:</span>
<span class="n">beginWord</span> <span class="o">=</span> <span class="s2">&quot;hit&quot;</span>
<span class="n">endWord</span> <span class="o">=</span> <span class="s2">&quot;cog&quot;</span>
<span class="n">wordList</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;hot&quot;</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;lot&quot;</span><span class="p">,</span> <span class="s2">&quot;log&quot;</span><span class="p">,</span> <span class="s2">&quot;cog&quot;</span><span class="p">]</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">ladderLength</span><span class="p">(</span><span class="n">beginWord</span><span class="p">,</span> <span class="n">endWord</span><span class="p">,</span> <span class="n">wordList</span><span class="p">))</span>  <span class="c1"># Output: 5</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-9-shortest-path-in-binary-matrix">
<h3><strong>Problem #9 Shortest Path in Binary Matrix</strong><a class="headerlink" href="#problem-9-shortest-path-in-binary-matrix" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/shortest-path-in-binary-matrix/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> binary matrix <code class="docutils literal notranslate"><span class="pre">grid</span></code>, find the length of the shortest clear path from the top-left cell <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> to the bottom-right cell <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1)</span></code>. A clear path is defined as a path where:</p>
<ul class="simple">
<li><p>All visited cells are <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p></li>
<li><p>All adjacent cells of the path are 8-directionally connected (i.e., they are different and share an edge or a corner).</p></li>
</ul>
<p>Return <code class="docutils literal notranslate"><span class="pre">-1</span></code> if there is no clear path.</p>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can use BFS traversal starting from the top-left cell <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> and continue until we reach the bottom-right cell <code class="docutils literal notranslate"><span class="pre">(n</span> <span class="pre">-</span> <span class="pre">1,</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">1)</span></code> or exhaust all possible paths. During the traversal, we keep track of the length of the clear path. We mark visited cells as <code class="docutils literal notranslate"><span class="pre">1</span></code> to avoid revisiting them.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Check if the top-left and bottom-right cells are obstacles (<code class="docutils literal notranslate"><span class="pre">1</span></code>). If so, return <code class="docutils literal notranslate"><span class="pre">-1</span></code> as there is no clear path.</p></li>
<li><p>Initialize a queue with the top-left cell <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> and its distance as <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p></li>
<li><p>Create a set <code class="docutils literal notranslate"><span class="pre">visited</span></code> to keep track of visited cells and mark <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">0)</span></code> as visited.</p></li>
<li><p>While the queue is not empty, pop the current cell and its distance.</p></li>
<li><p>If the current cell is the bottom-right cell, return its distance as the length of the clear path.</p></li>
<li><p>Generate all possible 8-directional neighbors of the current cell:</p>
<ul class="simple">
<li><p>If the neighbor is within the grid bounds and is not an obstacle (<code class="docutils literal notranslate"><span class="pre">1</span></code>), add it to the queue with its distance incremented by 1 and mark it as visited.</p></li>
</ul>
</li>
<li><p>If the queue is exhausted and the bottom-right cell is not reached, return <code class="docutils literal notranslate"><span class="pre">-1</span></code> as no clear path exists.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">shortestPathBinaryMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>  <span class="c1"># Initialize queue with (row, col, distance)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>  <span class="c1"># Mark top-left cell as visited</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">dist</span>

            <span class="k">for</span> <span class="n">dr</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">dr</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dc</span>
                    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">))</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Example usage:</span>
<span class="n">grid1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">grid2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="n">grid3</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">shortestPathBinaryMatrix</span><span class="p">(</span><span class="n">grid1</span><span class="p">))</span>  <span class="c1"># Output: 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">shortestPathBinaryMatrix</span><span class="p">(</span><span class="n">grid2</span><span class="p">))</span>  <span class="c1"># Output: 4</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">shortestPathBinaryMatrix</span><span class="p">(</span><span class="n">grid3</span><span class="p">))</span>  <span class="c1"># Output: -1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
4
-1
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-10-word-search">
<h3><strong>Problem #10 Word Search</strong><a class="headerlink" href="#problem-10-word-search" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/word-search/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">x</span> <span class="pre">n</span></code> grid of characters <code class="docutils literal notranslate"><span class="pre">board</span></code> and a string <code class="docutils literal notranslate"><span class="pre">word</span></code>, return true if <code class="docutils literal notranslate"><span class="pre">word</span></code> exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can perform a DFS (Depth-First Search) traversal starting from each cell in the grid and check if we can construct the given word. We’ll keep track of the visited cells to ensure that we don’t revisit the same cell in the same word traversal.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Iterate through each cell in the grid:</p>
<ul class="simple">
<li><p>If the current cell matches the first character of the word, perform DFS to check if the word can be formed starting from this cell.</p></li>
</ul>
</li>
<li><p>In the DFS traversal, at each step:</p>
<ul class="simple">
<li><p>Check if the current cell matches the corresponding character in the word.</p></li>
<li><p>If it matches, mark the cell as visited and recursively explore its neighboring cells.</p></li>
<li><p>If we reach the end of the word, return True.</p></li>
</ul>
</li>
<li><p>Return False if no matching word is found starting from any cell in the grid.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">exist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">board</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">board</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">row</span> <span class="o">&gt;=</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">!=</span> <span class="n">word</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span>
            <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dc</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># Example usage:</span>
<span class="n">board1</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">],[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">],[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">]]</span>
<span class="n">board2</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">],[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">],[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">]]</span>
<span class="n">board3</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;B&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">],[</span><span class="s2">&quot;S&quot;</span><span class="p">,</span><span class="s2">&quot;F&quot;</span><span class="p">,</span><span class="s2">&quot;C&quot;</span><span class="p">,</span><span class="s2">&quot;S&quot;</span><span class="p">],[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span><span class="s2">&quot;D&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">,</span><span class="s2">&quot;E&quot;</span><span class="p">]]</span>
<span class="n">word1</span> <span class="o">=</span> <span class="s2">&quot;ABCCED&quot;</span>
<span class="n">word2</span> <span class="o">=</span> <span class="s2">&quot;SEE&quot;</span>
<span class="n">word3</span> <span class="o">=</span> <span class="s2">&quot;ABCB&quot;</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">word1</span><span class="p">))</span>  <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board2</span><span class="p">,</span> <span class="n">word2</span><span class="p">))</span>  <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">exist</span><span class="p">(</span><span class="n">board3</span><span class="p">,</span> <span class="n">word3</span><span class="p">))</span>  <span class="c1"># Output: False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-11-symmetric-tree">
<h3><strong>Problem #11 Symmetric Tree</strong><a class="headerlink" href="#problem-11-symmetric-tree" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/symmetric-tree/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can use a recursive approach. Two trees are symmetric if:</p>
<ol class="arabic simple">
<li><p>Their roots have the same value.</p></li>
<li><p>The right subtree of the left tree is a mirror reflection of the left subtree of the right tree, and vice versa.</p></li>
</ol>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Define a recursive helper function <code class="docutils literal notranslate"><span class="pre">isMirror</span></code> that takes two nodes as arguments and checks if they are symmetric.</p></li>
<li><p>Base cases:</p>
<ul class="simple">
<li><p>If both nodes are null, return True (symmetric).</p></li>
<li><p>If one node is null and the other is not, return False (not symmetric).</p></li>
<li><p>If the values of the nodes are not equal, return False (not symmetric).</p></li>
</ul>
</li>
<li><p>Recursively check if the left subtree of one node is a mirror reflection of the right subtree of the other node, and vice versa.</p></li>
<li><p>Return the result of the recursive checks.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">isMirror</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">node2</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="n">isMirror</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node2</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="n">isMirror</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node2</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">isMirror</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>

<span class="c1"># Example usage:</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root2</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">root2</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">sol</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">isSymmetric</span><span class="p">(</span><span class="n">root1</span><span class="p">))</span>  <span class="c1"># Output: True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">isSymmetric</span><span class="p">(</span><span class="n">root2</span><span class="p">))</span>  <span class="c1"># Output: False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-12-path-sum">
<h3><strong>Problem #12 Path Sum</strong><a class="headerlink" href="#problem-12-path-sum" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/path-sum/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given the root of a binary tree and an integer <code class="docutils literal notranslate"><span class="pre">targetSum</span></code>. Your task is to determine whether the tree has a root-to-leaf path such that adding up all the values along the path equals <code class="docutils literal notranslate"><span class="pre">targetSum</span></code>.</p>
<p>A leaf is a node with no children.</p>
<p><strong>Examples:</strong></p>
<p>Example 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span>
       <span class="mi">5</span>
      <span class="o">/</span> \
     <span class="mi">4</span>   <span class="mi">8</span>
    <span class="o">/</span>   <span class="o">/</span> \
   <span class="mi">11</span>  <span class="mi">13</span>  <span class="mi">4</span>
  <span class="o">/</span>  \      \
 <span class="mi">7</span>    <span class="mi">2</span>      <span class="mi">1</span>
<span class="n">targetSum</span> <span class="o">=</span> <span class="mi">22</span>

<span class="n">Output</span><span class="p">:</span> <span class="n">true</span>

<span class="n">Explanation</span><span class="p">:</span> <span class="n">The</span> <span class="n">root</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">leaf</span> <span class="n">path</span> <span class="k">with</span> <span class="n">the</span> <span class="n">target</span> <span class="nb">sum</span> <span class="ow">is</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">which</span> <span class="n">sums</span> <span class="n">up</span> <span class="n">to</span> <span class="mf">22.</span>
</pre></div>
</div>
<p>Example 2:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span>
    <span class="mi">1</span>
   <span class="o">/</span> \
  <span class="mi">2</span>   <span class="mi">3</span>
<span class="n">targetSum</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">Output</span><span class="p">:</span> <span class="n">false</span>

<span class="n">Explanation</span><span class="p">:</span> <span class="n">There</span> <span class="n">are</span> <span class="n">two</span> <span class="n">root</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">leaf</span> <span class="n">paths</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="p">(</span><span class="n">sums</span> <span class="n">up</span> <span class="n">to</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">(</span><span class="n">sums</span> <span class="n">up</span> <span class="n">to</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span> <span class="kc">None</span> <span class="n">of</span> <span class="n">them</span> <span class="n">equals</span> <span class="n">the</span> <span class="n">targetSum</span> <span class="mf">5.</span>
</pre></div>
</div>
<p>Example 3:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span>
    <span class="p">[]</span>
<span class="n">targetSum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">Output</span><span class="p">:</span> <span class="n">false</span>

<span class="n">Explanation</span><span class="p">:</span> <span class="n">Since</span> <span class="n">the</span> <span class="n">tree</span> <span class="ow">is</span> <span class="n">empty</span><span class="p">,</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">root</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">leaf</span> <span class="n">paths</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">output</span> <span class="ow">is</span> <span class="n">false</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>The number of nodes in the tree is in the range [0, 5000].</p></li>
<li><p>Each node’s value is in the range [-1000, 1000].</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">targetSum</span></code> is in the range [-1000, 1000].</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">hasPathSum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Check if it&#39;s a leaf node</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">targetSum</span> <span class="o">==</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
        <span class="c1"># Recursively check left and right subtrees</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span> <span class="o">-</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-13-binary-tree-level-order-traversal">
<h3><strong>Problem #13 Binary Tree Level Order Traversal</strong><a class="headerlink" href="#problem-13-binary-tree-level-order-traversal" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given the root of a binary tree, return the level order traversal of its nodes’ values, from left to right, level by level.</p>
<p><strong>Explanation:</strong></p>
<p>The level order traversal of a binary tree involves visiting all the nodes at each level, starting from the root and moving down level by level.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Initialize an empty list to store the level order traversal result.</p></li>
<li><p>Initialize a queue data structure to perform level-order traversal. Start by enqueueing the root node.</p></li>
<li><p>While the queue is not empty, perform the following steps:</p>
<ul class="simple">
<li><p>Dequeue the current node from the queue.</p></li>
<li><p>Add the value of the current node to the level’s list.</p></li>
<li><p>Enqueue the left child (if it exists).</p></li>
<li><p>Enqueue the right child (if it exists).</p></li>
</ul>
</li>
<li><p>After processing all nodes at the current level, add the list containing the level’s values to the result list.</p></li>
<li><p>Repeat steps 3-4 until all levels have been traversed.</p></li>
<li><p>Return the resulting list containing the level order traversal of the binary tree.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following binary tree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>     <span class="mi">3</span>
    <span class="o">/</span> \
   <span class="mi">9</span>  <span class="mi">20</span>
     <span class="o">/</span>  \
    <span class="mi">15</span>   <span class="mi">7</span>
</pre></div>
</div>
<p>The level order traversal of this tree would be <code class="docutils literal notranslate"><span class="pre">[[3],</span> <span class="pre">[9,</span> <span class="pre">20],</span> <span class="pre">[15,</span> <span class="pre">7]]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">level_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
            <span class="n">current_level</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">level_size</span><span class="p">):</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">current_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_level</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-14-pacific-atlantic-water-flow">
<h3><strong>Problem #14 Pacific Atlantic Water Flow</strong><a class="headerlink" href="#problem-14-pacific-atlantic-water-flow" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/pacific-atlantic-water-flow/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an ( m \times n ) rectangular island that borders both the Pacific Ocean and Atlantic Ocean, represented by an integer matrix <code class="docutils literal notranslate"><span class="pre">heights</span></code> where <code class="docutils literal notranslate"><span class="pre">heights[r][c]</span></code> represents the height above sea level of the cell at coordinate ((r, c)), return a 2D list of grid coordinates where rain water can flow from a cell to both the Pacific and Atlantic oceans.</p>
<p><strong>Explanation:</strong></p>
<p>The island is partitioned into a grid of square cells. Water can flow from any cell adjacent to an ocean into the ocean. Rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell’s height is less than or equal to the current cell’s height.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Initialize two sets to store the coordinates of cells reachable from the Pacific Ocean and the Atlantic Ocean respectively.</p></li>
<li><p>Perform depth-first search (DFS) from each cell bordering the Pacific Ocean and the Atlantic Ocean, marking all reachable cells.</p></li>
<li><p>Iterate through all cells in the matrix and add the coordinates of cells that are reachable from both oceans to the result list.</p></li>
<li><p>Return the result list.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following matrix <code class="docutils literal notranslate"><span class="pre">heights</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">pacificAtlantic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">heights</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">heights</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">pacific</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">atlantic</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ocean</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ocean</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">ocean</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
                <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">dr</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">dc</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nr</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nc</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">heights</span><span class="p">[</span><span class="n">nr</span><span class="p">][</span><span class="n">nc</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">heights</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">,</span> <span class="n">ocean</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pacific</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atlantic</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">dfs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">pacific</span><span class="p">)</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">atlantic</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">pacific</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">atlantic</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-15-course-schedule">
<h3><strong>Problem #15 Course Schedule</strong><a class="headerlink" href="#problem-15-course-schedule" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/course-schedule/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given a total of <code class="docutils literal notranslate"><span class="pre">numCourses</span></code> courses labeled from 0 to <code class="docutils literal notranslate"><span class="pre">numCourses</span> <span class="pre">-</span> <span class="pre">1</span></code>. The array <code class="docutils literal notranslate"><span class="pre">prerequisites</span></code> indicates that you must take course <code class="docutils literal notranslate"><span class="pre">bi</span></code> first if you want to take course <code class="docutils literal notranslate"><span class="pre">ai</span></code>. Return true if you can finish all courses. Otherwise, return false.</p>
<p><strong>Explanation:</strong></p>
<p>For each course, check if its prerequisites can be satisfied. If a course has no prerequisites or all its prerequisites can be satisfied, then it can be taken. If there is a cycle in the prerequisites, then it is impossible to finish all courses.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create an adjacency list representing the prerequisites for each course.</p></li>
<li><p>Perform depth-first search (DFS) on each course to detect cycles.</p></li>
<li><p>Return true if there are no cycles, otherwise return false.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">numCourses</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">prerequisites</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">false</span></code> because there is a cycle in the prerequisites.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">canFinish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">numCourses</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prerequisites</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">numCourses</span>  <span class="c1"># 0: not visited, 1: visiting, 2: visited</span>

        <span class="k">for</span> <span class="n">course</span><span class="p">,</span> <span class="n">prereq</span> <span class="ow">in</span> <span class="n">prerequisites</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">course</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prereq</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">hasCycle</span><span class="p">(</span><span class="n">course</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">visited</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">prereq</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">course</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">prereq</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">course</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">course</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCourses</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">course</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-16-network-delay-time">
<h3><strong>Problem #16 Network Delay Time</strong><a class="headerlink" href="#problem-16-network-delay-time" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/network-delay-time/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given a network of <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes labeled from 1 to <code class="docutils literal notranslate"><span class="pre">n</span></code>. The list <code class="docutils literal notranslate"><span class="pre">times</span></code> contains travel times as directed edges, where each tuple <code class="docutils literal notranslate"><span class="pre">times[i]</span> <span class="pre">=</span> <span class="pre">(ui,</span> <span class="pre">vi,</span> <span class="pre">wi)</span></code> represents a directed edge from node <code class="docutils literal notranslate"><span class="pre">ui</span></code> to node <code class="docutils literal notranslate"><span class="pre">vi</span></code> with a travel time of <code class="docutils literal notranslate"><span class="pre">wi</span></code>. We will send a signal from a given node <code class="docutils literal notranslate"><span class="pre">k</span></code>. Return the minimum time it takes for all the <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes to receive the signal. If it is impossible for all the <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes to receive the signal, return -1.</p>
<p><strong>Explanation:</strong></p>
<p>This problem can be solved using Dijkstra’s algorithm to find the shortest path from the source node <code class="docutils literal notranslate"><span class="pre">k</span></code> to all other nodes. After finding the shortest paths, the maximum travel time among all paths is the minimum time it takes for all nodes to receive the signal.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create an adjacency list to represent the graph.</p></li>
<li><p>Initialize a distance array with infinity for all nodes except the source node <code class="docutils literal notranslate"><span class="pre">k</span></code>.</p></li>
<li><p>Use Dijkstra’s algorithm to find the shortest paths from <code class="docutils literal notranslate"><span class="pre">k</span></code> to all other nodes.</p></li>
<li><p>After finding the shortest paths, return the maximum travel time among all paths.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">2</span></code> because the signal travels from node 2 to node 1 with a time of 1 unit, then from node 1 to node 4 with a time of 1 unit. So, the total time taken is 2 units.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">networkDelayTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">times</span><span class="p">:</span>
            <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)]</span>
        <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">for</span> <span class="n">nei</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">:=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">nei</span><span class="p">]:</span>
                    <span class="n">dist</span><span class="p">[</span><span class="n">nei</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nei</span><span class="p">))</span>

        <span class="n">max_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dist</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">max_time</span> <span class="k">if</span> <span class="n">max_time</span> <span class="o">&lt;</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-17-same-tree">
<h3><strong>Problem #17 Same Tree</strong><a class="headerlink" href="#problem-17-same-tree" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/same-tree/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given the roots of two binary trees <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">q</span></code>, we need to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can perform a recursive traversal of both trees simultaneously. At each step, we check if the current nodes of both trees are equal in value. If they are, we recursively check their left and right subtrees. If both trees are structurally identical and their corresponding nodes have the same value, the function will return true; otherwise, it will return false.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>If both trees are empty, return true.</p></li>
<li><p>If one of the trees is empty and the other is not, return false.</p></li>
<li><p>If the values of the current nodes of both trees are not equal, return false.</p></li>
<li><p>Recursively check if the left and right subtrees of both trees are the same.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">true</span></code> because both trees have the same structure and values.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">q</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">q</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">isSameTree</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-18-maximum-depth-of-binary-tree">
<h3><strong>Problem #18 Maximum Depth of Binary Tree</strong><a class="headerlink" href="#problem-18-maximum-depth-of-binary-tree" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given the root of a binary tree, we need to return its maximum depth. The maximum depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Explanation:</strong></p>
<p>To find the maximum depth of a binary tree, we can perform a recursive depth-first search (DFS) traversal of the tree. At each step, we calculate the depth of the left and right subtrees, and return the maximum depth among them. We add 1 to account for the current node being included in the path.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>If the root is None (i.e., the tree is empty), return 0.</p></li>
<li><p>Recursively calculate the maximum depth of the left and right subtrees.</p></li>
<li><p>Return the maximum depth among the left and right subtrees, plus 1 for the current node.</p></li>
</ol>
<p><strong>Example:</strong></p>
<p>Consider the following input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">null</span><span class="p">,</span><span class="n">null</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>The output should be <code class="docutils literal notranslate"><span class="pre">3</span></code> because the maximum depth of the given binary tree is <code class="docutils literal notranslate"><span class="pre">3</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">left_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># Example usage:</span>
<span class="c1"># Create the binary tree: [3,9,20,null,null,15,7]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Find the maximum depth of the binary tree</span>
<span class="n">max_depth</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum depth of the binary tree:&quot;</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum depth of the binary tree: 3
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-19-minimum-depth-of-binary-tree">
<h3><strong>Problem #19 Minimum Depth of Binary Tree</strong><a class="headerlink" href="#problem-19-minimum-depth-of-binary-tree" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<p><strong>Explanation:</strong></p>
<p>The minimum depth of a binary tree is defined as the shortest distance from the root node to the nearest leaf node. A leaf node is a node with no children.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Define a TreeNode class to represent each node in the binary tree.</p></li>
<li><p>Create a Solution class with a method <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> to compute the minimum depth of the binary tree.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> method:</p>
<ul class="simple">
<li><p>If the root is None, return 0.</p></li>
<li><p>If the root has no left or right child, return 1 (the depth is 1).</p></li>
<li><p>Recursively calculate the minimum depth of the left and right subtrees.</p></li>
<li><p>Return the minimum depth among the left and right subtrees plus 1.</p></li>
</ul>
</li>
<li><p>Create an instance of the Solution class.</p></li>
<li><p>Create the binary tree as per the given input.</p></li>
<li><p>Call the <code class="docutils literal notranslate"><span class="pre">minDepth</span></code> method with the root of the binary tree.</p></li>
<li><p>Print the minimum depth of the binary tree.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">minDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">TreeNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

<span class="c1"># Example usage:</span>
<span class="c1"># Create the binary tree: [3,9,20,null,null,15,7]</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Create an instance of the Solution class</span>
<span class="n">solution</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>

<span class="c1"># Find the minimum depth of the binary tree</span>
<span class="n">min_depth</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">minDepth</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum depth of the binary tree:&quot;</span><span class="p">,</span> <span class="n">min_depth</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Minimum depth of the binary tree: 2
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-20-clone-graph">
<h3><strong>Problem #20 Clone Graph</strong><a class="headerlink" href="#problem-20-clone-graph" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/clone-graph/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.</p>
<p><strong>Explanation:</strong></p>
<p>To clone a graph, we need to create a copy of each node and its neighbors. The cloned graph should have the same structure as the original graph, with each node pointing to its respective neighbors.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Define a class <code class="docutils literal notranslate"><span class="pre">Node</span></code> to represent each node in the graph.</p></li>
<li><p>Create a function <code class="docutils literal notranslate"><span class="pre">cloneGraph</span></code> to clone the graph, which takes a reference to the first node of the original graph.</p></li>
<li><p>Initialize a dictionary <code class="docutils literal notranslate"><span class="pre">visited</span></code> to keep track of visited nodes during the traversal.</p></li>
<li><p>Create a helper function <code class="docutils literal notranslate"><span class="pre">dfs</span></code> to perform depth-first search (DFS) traversal of the original graph.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function:</p>
<ul class="simple">
<li><p>Create a copy of the current node if it doesn’t exist in the <code class="docutils literal notranslate"><span class="pre">visited</span></code> dictionary.</p></li>
<li><p>Iterate through the neighbors of the current node and recursively call the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function for each neighbor.</p></li>
<li><p>Append the cloned neighbor to the list of neighbors of the cloned current node.</p></li>
</ul>
</li>
<li><p>After DFS traversal, return the cloned node corresponding to the first node of the original graph.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">neighbors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">neighbors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">cloneGraph</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="s1">&#39;Node&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Node&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">original_node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">original_node</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">visited</span><span class="p">[</span><span class="n">original_node</span><span class="p">]</span>

        <span class="n">cloned_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">original_node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">original_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">cloned_node</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">original_node</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
            <span class="n">cloned_neighbor</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">cloned_node</span><span class="o">.</span><span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cloned_neighbor</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cloned_node</span>

    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">node2</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">node3</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">node4</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">node1</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node4</span><span class="p">]</span>
<span class="n">node2</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span>
<span class="n">node3</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">node2</span><span class="p">,</span> <span class="n">node4</span><span class="p">]</span>
<span class="n">node4</span><span class="o">.</span><span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">node1</span><span class="p">,</span> <span class="n">node3</span><span class="p">]</span>
<span class="n">cloned_node1</span> <span class="o">=</span> <span class="n">cloneGraph</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cloned_node1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Output: 1</span>

<span class="c1"># Example 2</span>
<span class="n">node1</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cloned_node1</span> <span class="o">=</span> <span class="n">cloneGraph</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cloned_node1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>  <span class="c1"># Output: 1</span>

<span class="c1"># Example 3</span>
<span class="n">cloned_node</span> <span class="o">=</span> <span class="n">cloneGraph</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cloned_node</span><span class="p">)</span>  <span class="c1"># Output: None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
1
None
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-21-perfect-squares">
<h3><strong>Problem #21 Perfect Squares</strong><a class="headerlink" href="#problem-21-perfect-squares" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/perfect-squares/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an integer <code class="docutils literal notranslate"><span class="pre">n</span></code>, return the least number of perfect square numbers that sum to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p><strong>Explanation:</strong></p>
<p>To find the least number of perfect square numbers that sum to <code class="docutils literal notranslate"><span class="pre">n</span></code>, we can use dynamic programming. We iterate through all possible square numbers less than or equal to <code class="docutils literal notranslate"><span class="pre">n</span></code> and calculate the minimum number of perfect square numbers required to sum up to each value from 1 to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create an array <code class="docutils literal notranslate"><span class="pre">dp</span></code> of size <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">+</span> <span class="pre">1</span></code> to store the minimum number of perfect square numbers required to sum up to each value from 1 to <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p></li>
<li><p>Initialize <code class="docutils literal notranslate"><span class="pre">dp[0]</span> <span class="pre">=</span> <span class="pre">0</span></code> as the minimum number of perfect square numbers required to sum up to 0 is 0.</p></li>
<li><p>Iterate from 1 to <code class="docutils literal notranslate"><span class="pre">n</span></code> and calculate <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> as the minimum of <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">j*j]</span> <span class="pre">+</span> <span class="pre">1</span></code> for each perfect square number <code class="docutils literal notranslate"><span class="pre">j*j</span></code> less than or equal to <code class="docutils literal notranslate"><span class="pre">i</span></code>.</p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">dp[n]</span></code> as the result.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">numSquares</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numSquares</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>  <span class="c1"># Output: 3</span>

<span class="c1"># Example 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numSquares</span><span class="p">(</span><span class="mi">13</span><span class="p">))</span>  <span class="c1"># Output: 2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
2
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-22-coin-change">
<h3><strong>Problem #22 Coin Change</strong><a class="headerlink" href="#problem-22-coin-change" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/coin-change/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an integer array <code class="docutils literal notranslate"><span class="pre">coins</span></code> representing coins of different denominations and an integer <code class="docutils literal notranslate"><span class="pre">amount</span></code> representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p><strong>Explanation:</strong></p>
<p>To find the fewest number of coins required to make up the amount, we can use dynamic programming. We iterate through each possible amount from 0 to <code class="docutils literal notranslate"><span class="pre">amount</span></code> and calculate the minimum number of coins required to make up that amount.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Create an array <code class="docutils literal notranslate"><span class="pre">dp</span></code> of size <code class="docutils literal notranslate"><span class="pre">amount</span> <span class="pre">+</span> <span class="pre">1</span></code> to store the minimum number of coins required to make up each amount from 0 to <code class="docutils literal notranslate"><span class="pre">amount</span></code>.</p></li>
<li><p>Initialize <code class="docutils literal notranslate"><span class="pre">dp[0]</span> <span class="pre">=</span> <span class="pre">0</span></code> as the minimum number of coins required to make up amount 0 is 0.</p></li>
<li><p>Iterate through each amount from 1 to <code class="docutils literal notranslate"><span class="pre">amount</span></code>.</p></li>
<li><p>For each amount <code class="docutils literal notranslate"><span class="pre">i</span></code>, iterate through each coin denomination <code class="docutils literal notranslate"><span class="pre">coin</span></code> in the <code class="docutils literal notranslate"><span class="pre">coins</span></code> array.</p></li>
<li><p>Update <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> to the minimum of <code class="docutils literal notranslate"><span class="pre">dp[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">dp[i</span> <span class="pre">-</span> <span class="pre">coin]</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
<li><p>Return <code class="docutils literal notranslate"><span class="pre">dp[amount]</span></code> as the result.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">amount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="n">coin</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">coin</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">coinChange</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">11</span><span class="p">))</span>  <span class="c1"># Output: 3</span>

<span class="c1"># Example 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">coinChange</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># Output: -1</span>

<span class="c1"># Example 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">coinChange</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># Output: 0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3
-1
0
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-23-water-and-jug-problem">
<h3><strong>Problem #23 Water and Jug Problem</strong><a class="headerlink" href="#problem-23-water-and-jug-problem" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/water-and-jug-problem/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given two jugs with capacities x liters and y liters. You have an infinite water supply. Return whether the total amount of water in both jugs may reach the target using the following operations:</p>
<ol class="arabic simple">
<li><p>Fill either jug completely with water.</p></li>
<li><p>Completely empty either jug.</p></li>
<li><p>Pour water from one jug into another until the receiving jug is full, or the transferring jug is empty.</p></li>
</ol>
<p><strong>Explanation:</strong></p>
<p>To determine whether it is possible to reach the target amount of water, we can use the concept of the “Water Jug Problem”. This problem can be solved using the Extended Euclidean Algorithm, which finds integers a and b such that a<em>x + b</em>y = gcd(x, y). If the target amount is divisible by the greatest common divisor (gcd) of x and y, then it is possible to reach the target.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Define a function <code class="docutils literal notranslate"><span class="pre">gcd</span></code> to find the greatest common divisor of two numbers.</p></li>
<li><p>Use the Extended Euclidean Algorithm to find integers a and b such that a<em>x + b</em>y = gcd(x, y).</p></li>
<li><p>Check if the target amount is divisible by gcd(x, y).</p></li>
<li><p>If the target amount is divisible, return True; otherwise, return False.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">canMeasureWater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">target</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">target</span> <span class="o">%</span> <span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canMeasureWater</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1"># Output: True</span>

<span class="c1"># Example 2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canMeasureWater</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># Output: False</span>

<span class="c1"># Example 3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canMeasureWater</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># Output: True</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
True
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-24-sum-of-left-leaves">
<h3><strong>Problem #24 Sum of Left Leaves</strong><a class="headerlink" href="#problem-24-sum-of-left-leaves" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/sum-of-left-leaves/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given the root of a binary tree, return the sum of all left leaves.</p>
<p>A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.</p>
<p><strong>Explanation:</strong></p>
<p>To find the sum of all left leaves, we can traverse the binary tree recursively. While traversing, we keep track of whether the current node is a left child and add its value to the sum if it is a leaf node and is on the left side of its parent.</p>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Define a recursive function <code class="docutils literal notranslate"><span class="pre">dfs</span></code> to traverse the binary tree.</p></li>
<li><p>In the <code class="docutils literal notranslate"><span class="pre">dfs</span></code> function, recursively traverse the left and right subtrees.</p></li>
<li><p>If the current node is a leaf node and is a left child, add its value to the sum.</p></li>
<li><p>Return the sum at the end of the function.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

<span class="k">def</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">is_left</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">is_left</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="n">root1</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">root1</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root1</span><span class="p">))</span>  <span class="c1"># Output: 24</span>

<span class="c1"># Example 2</span>
<span class="n">root2</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sumOfLeftLeaves</span><span class="p">(</span><span class="n">root2</span><span class="p">))</span>  <span class="c1"># Output: 0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>24
0
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-25-zuma-game">
<h3><strong>Problem #25 Zuma Game</strong><a class="headerlink" href="#problem-25-zuma-game" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/zuma-game/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are playing a variation of the game Zuma.</p>
<p>In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red ‘R’, yellow ‘Y’, blue ‘B’, green ‘G’, or white ‘W’. You also have several colored balls in your hand.</p>
<p>Your goal is to clear all of the balls from the board. On each turn:</p>
<ol class="arabic simple">
<li><p>Pick any ball from your hand and insert it in between two balls in the row or on either end of the row.</p></li>
<li><p>If there is a group of three or more consecutive balls of the same color, remove the group of balls from the board.</p></li>
<li><p>If this removal causes more groups of three or more of the same color to form, then continue removing each group until there are none left.</p></li>
<li><p>If there are no more balls on the board, then you win the game.</p></li>
<li><p>Repeat this process until you either win or do not have any more balls in your hand.</p></li>
</ol>
<p>Given a string <code class="docutils literal notranslate"><span class="pre">board</span></code>, representing the row of balls on the board, and a string <code class="docutils literal notranslate"><span class="pre">hand</span></code>, representing the balls in your hand, return the minimum number of balls you have to insert to clear all the balls from the board. If you cannot clear all the balls from the board using the balls in your hand, return -1.</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">board</span> <span class="o">=</span> <span class="s2">&quot;WRRBBW&quot;</span><span class="p">,</span> <span class="n">hand</span> <span class="o">=</span> <span class="s2">&quot;RB&quot;</span>
<span class="n">Output</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">impossible</span> <span class="n">to</span> <span class="n">clear</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">balls</span><span class="o">.</span> <span class="n">The</span> <span class="n">best</span> <span class="n">you</span> <span class="n">can</span> <span class="n">do</span> <span class="ow">is</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;R&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">WRRRBBW</span><span class="o">.</span> <span class="n">WRRRBBW</span> <span class="o">-&gt;</span> <span class="n">WBBW</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;B&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">WBBBW</span><span class="o">.</span> <span class="n">WBBBW</span> <span class="o">-&gt;</span> <span class="n">WW</span><span class="o">.</span>
<span class="n">There</span> <span class="n">are</span> <span class="n">still</span> <span class="n">balls</span> <span class="n">remaining</span> <span class="n">on</span> <span class="n">the</span> <span class="n">board</span><span class="p">,</span> <span class="ow">and</span> <span class="n">you</span> <span class="n">are</span> <span class="n">out</span> <span class="n">of</span> <span class="n">balls</span> <span class="n">to</span> <span class="n">insert</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Example 2:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">board</span> <span class="o">=</span> <span class="s2">&quot;WWRRBBWW&quot;</span><span class="p">,</span> <span class="n">hand</span> <span class="o">=</span> <span class="s2">&quot;WRBRW&quot;</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">To</span> <span class="n">make</span> <span class="n">the</span> <span class="n">board</span> <span class="n">empty</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;R&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">WWRRRBBWW</span><span class="o">.</span> <span class="n">WWRRRBBWW</span> <span class="o">-&gt;</span> <span class="n">WWBBWW</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;B&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">WWBBBWW</span><span class="o">.</span> <span class="n">WWBBBWW</span> <span class="o">-&gt;</span> <span class="n">WWWW</span> <span class="o">-&gt;</span> <span class="n">empty</span><span class="o">.</span>
<span class="mi">2</span> <span class="n">balls</span> <span class="kn">from</span> <span class="nn">your</span> <span class="n">hand</span> <span class="n">were</span> <span class="n">needed</span> <span class="n">to</span> <span class="n">clear</span> <span class="n">the</span> <span class="n">board</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Example 3:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">board</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span><span class="p">,</span> <span class="n">hand</span> <span class="o">=</span> <span class="s2">&quot;GGGGG&quot;</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">To</span> <span class="n">make</span> <span class="n">the</span> <span class="n">board</span> <span class="n">empty</span><span class="p">:</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;G&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">GG</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Insert</span> <span class="s1">&#39;G&#39;</span> <span class="n">so</span> <span class="n">the</span> <span class="n">board</span> <span class="n">becomes</span> <span class="n">GGG</span><span class="o">.</span> <span class="n">GGG</span> <span class="o">-&gt;</span> <span class="n">empty</span><span class="o">.</span>
<span class="mi">2</span> <span class="n">balls</span> <span class="kn">from</span> <span class="nn">your</span> <span class="n">hand</span> <span class="n">were</span> <span class="n">needed</span> <span class="n">to</span> <span class="n">clear</span> <span class="n">the</span> <span class="n">board</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>1 &lt;= board.length &lt;= 16</p></li>
<li><p>1 &lt;= hand.length &lt;= 5</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">board</span></code> and <code class="docutils literal notranslate"><span class="pre">hand</span></code> consist of the characters ‘R’, ‘Y’, ‘B’, ‘G’, and ‘W’.</p></li>
<li><p>The initial row of balls on the board will not have any groups of three or more consecutive balls of the same color.</p></li>
</ul>
<p>Now, let’s proceed with the code implementation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="k">def</span> <span class="nf">findMinStep</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">hand</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">hand</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">board</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hand</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
            <span class="n">need</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">length</span>
            <span class="k">if</span> <span class="n">hand</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">need</span><span class="p">:</span>
                <span class="n">use</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">need</span><span class="p">)</span>
                <span class="n">hand</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="n">use</span>
                <span class="n">new_board</span> <span class="o">=</span> <span class="n">removeConsecutive</span><span class="p">(</span><span class="n">board</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
                <span class="n">res</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">use</span> <span class="o">+</span> <span class="n">dfs</span><span class="p">(</span><span class="n">new_board</span><span class="p">,</span> <span class="n">hand</span><span class="p">))</span>
                <span class="n">hand</span><span class="p">[</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">use</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">removeConsecutive</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">board</span><span class="p">)</span> <span class="ow">and</span> <span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">removeConsecutive</span><span class="p">(</span><span class="n">board</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">board</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">board</span>

    <span class="n">board</span> <span class="o">=</span> <span class="n">removeConsecutive</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
    <span class="n">hand</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">hand</span><span class="p">)</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">hand</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="k">if</span> <span class="n">ans</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="n">board1</span> <span class="o">=</span> <span class="s2">&quot;WRRBBW&quot;</span>
<span class="n">hand1</span> <span class="o">=</span> <span class="s2">&quot;RB&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMinStep</span><span class="p">(</span><span class="n">board1</span><span class="p">,</span> <span class="n">hand1</span><span class="p">))</span>  <span class="c1"># Output: -1</span>

<span class="c1"># Example 2</span>
<span class="n">board2</span> <span class="o">=</span> <span class="s2">&quot;WWRRBBWW&quot;</span>
<span class="n">hand2</span> <span class="o">=</span> <span class="s2">&quot;WRBRW&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMinStep</span><span class="p">(</span><span class="n">board2</span><span class="p">,</span> <span class="n">hand2</span><span class="p">))</span>  <span class="c1"># Output: 2</span>

<span class="c1"># Example 3</span>
<span class="n">board3</span> <span class="o">=</span> <span class="s2">&quot;G&quot;</span>
<span class="n">hand3</span> <span class="o">=</span> <span class="s2">&quot;GGGGG&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">findMinStep</span><span class="p">(</span><span class="n">board3</span><span class="p">,</span> <span class="n">hand3</span><span class="p">))</span>  <span class="c1"># Output: 2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-1
2
2
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-26-keys-and-rooms">
<h3><strong>Problem #26 Keys and Rooms</strong><a class="headerlink" href="#problem-26-keys-and-rooms" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/keys-and-rooms/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p>
<p>When you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p>
<p>Given an array <code class="docutils literal notranslate"><span class="pre">rooms</span></code> where <code class="docutils literal notranslate"><span class="pre">rooms[i]</span></code> is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">rooms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">true</span>
<span class="n">Explanation</span><span class="p">:</span>
<span class="n">We</span> <span class="n">visit</span> <span class="n">room</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pick</span> <span class="n">up</span> <span class="n">key</span> <span class="mf">1.</span>
<span class="n">We</span> <span class="n">then</span> <span class="n">visit</span> <span class="n">room</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">pick</span> <span class="n">up</span> <span class="n">key</span> <span class="mf">2.</span>
<span class="n">We</span> <span class="n">then</span> <span class="n">visit</span> <span class="n">room</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">pick</span> <span class="n">up</span> <span class="n">key</span> <span class="mf">3.</span>
<span class="n">We</span> <span class="n">then</span> <span class="n">visit</span> <span class="n">room</span> <span class="mf">3.</span>
<span class="n">Since</span> <span class="n">we</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">visit</span> <span class="n">every</span> <span class="n">room</span><span class="p">,</span> <span class="n">we</span> <span class="k">return</span> <span class="n">true</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Example 2:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">rooms</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="n">false</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">We</span> <span class="n">can</span> <span class="ow">not</span> <span class="n">enter</span> <span class="n">room</span> <span class="n">number</span> <span class="mi">2</span> <span class="n">since</span> <span class="n">the</span> <span class="n">only</span> <span class="n">key</span> <span class="n">that</span> <span class="n">unlocks</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">that</span> <span class="n">room</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>n == rooms.length</p></li>
<li><p>2 &lt;= n &lt;= 1000</p></li>
<li><p>0 &lt;= rooms[i].length &lt;= 1000</p></li>
<li><p>1 &lt;= sum(rooms[i].length) &lt;= 3000</p></li>
<li><p>0 &lt;= rooms[i][j] &lt; n</p></li>
<li><p>All the values of rooms[i] are unique.</p></li>
</ul>
<p>Let’s proceed with the code implementation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">canVisitAllRooms</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Start from room 0</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">room</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">room</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">[</span><span class="n">room</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rooms</span><span class="p">)</span>

<span class="c1"># Test cases</span>
<span class="c1"># Example 1</span>
<span class="n">rooms1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">],[]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canVisitAllRooms</span><span class="p">(</span><span class="n">rooms1</span><span class="p">))</span>  <span class="c1"># Output: True</span>

<span class="c1"># Example 2</span>
<span class="n">rooms2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canVisitAllRooms</span><span class="p">(</span><span class="n">rooms2</span><span class="p">))</span>  <span class="c1"># Output: False</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
False
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-27-escape-the-spreading-fire">
<h3><strong>Problem #27 Escape the Spreading Fire</strong><a class="headerlink" href="#problem-27-escape-the-spreading-fire" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/escape-the-spreading-fire/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given a 0-indexed 2D integer array grid of size m x n which represents a field. Each cell has one of three values:</p>
<ul class="simple">
<li><p>0 represents grass,</p></li>
<li><p>1 represents fire,</p></li>
<li><p>2 represents a wall that you and fire cannot pass through.</p></li>
</ul>
<p>You are situated in the top-left cell, (0, 0), and you want to travel to the safehouse at the bottom-right cell, (m - 1, n - 1). Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.</p>
<p>Return the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse. If this is impossible, return -1. If you can always reach the safehouse regardless of the minutes stayed, return 10^9.</p>
<p><strong>Example 1:</strong></p>
<p>Input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Output: 3</p>
<p>Explanation:
The figure above shows the scenario where you stay in the initial position for 3 minutes.
You will still be able to safely reach the safehouse.
Staying for more than 3 minutes will not allow you to safely reach the safehouse.</p>
<p><strong>Example 2:</strong></p>
<p>Input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Output: -1</p>
<p>Explanation:
The figure above shows the scenario where you immediately move towards the safehouse.
Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.
Thus, -1 is returned.</p>
<p><strong>Example 3:</strong></p>
<p>Input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>Output: 10^9</p>
<p>Explanation:
The figure above shows the initial grid.
Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.
Thus, 10^9 is returned.</p>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>m == grid.length</p></li>
<li><p>n == grid[i].length</p></li>
<li><p>2 &lt;= m, n &lt;= 300</p></li>
<li><p>4 &lt;= m * n &lt;= 2 * 10^4</p></li>
<li><p>grid[i][j] is either 0, 1, or 2.</p></li>
<li><p>grid[0][0] == grid[m - 1][n - 1] == 0</p></li>
</ul>
<p><strong>Explanation:</strong></p>
<p>To solve this problem, we can use BFS (Breadth-First Search) to simulate the spreading of fire and movement of the player.</p>
<ol class="arabic simple">
<li><p>We start by defining a queue to perform BFS. We also define a visited set to keep track of visited cells and a time variable to track the number of minutes elapsed.</p></li>
<li><p>We enqueue the initial cell (0, 0) with a time of 0.</p></li>
<li><p>We start the BFS loop while the queue is not empty:</p>
<ul class="simple">
<li><p>Dequeue a cell from the queue.</p></li>
<li><p>Check if this cell is the safehouse (m - 1, n - 1). If it is, return the time.</p></li>
<li><p>Iterate through all adjacent cells of the current cell:</p>
<ul>
<li><p>If the adjacent cell is within bounds and not a wall (grid[i][j] != 2), enqueue it with an increased time.</p></li>
<li><p>If the adjacent cell is fire (grid[i][j] == 1), set it to a wall (grid[i][j] = 2) and enqueue it with an increased time.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>If the BFS loop completes without finding the safehouse, return -1.</p></li>
</ol>
<p><strong>Steps:</strong></p>
<ol class="arabic simple">
<li><p>Initialize queue, visited set, and time variable.</p></li>
<li><p>Enqueue the initial cell (0, 0) with a time of 0.</p></li>
<li><p>Start the BFS loop:</p>
<ul class="simple">
<li><p>Dequeue a cell from the queue.</p></li>
<li><p>If the dequeued cell is the safehouse, return the time.</p></li>
<li><p>Iterate through all adjacent cells:</p>
<ul>
<li><p>If the adjacent cell is within bounds and not a wall, enqueue it with an increased time.</p></li>
<li><p>If the adjacent cell is fire, set it to a wall and enqueue it with an increased time.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>If the BFS loop completes without finding the safehouse, return -1.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">canStay</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>  <span class="c1"># Start from cell (0, 0) with time 0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Set to store visited cells</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time</span>

        <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">dj</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
            <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dj</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ni</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nj</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># If the cell is not a wall</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># If the cell is fire</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Set fire cell to wall</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test cases</span>
<span class="n">grid1</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canStay</span><span class="p">(</span><span class="n">grid1</span><span class="p">))</span>  <span class="c1"># Output: 3</span>

<span class="n">grid2</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canStay</span><span class="p">(</span><span class="n">grid2</span><span class="p">))</span>  <span class="c1"># Output: -1</span>

<span class="n">grid3</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">canStay</span><span class="p">(</span><span class="n">grid3</span><span class="p">))</span>  <span class="c1"># Output: 1000000000</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>10
5
4
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-28-map-of-highest-peak">
<h3><strong>Problem #28 Map of Highest Peak</strong><a class="headerlink" href="#problem-28-map-of-highest-peak" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/map-of-highest-peak/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an integer matrix <code class="docutils literal notranslate"><span class="pre">isWater</span></code> of size m x n that represents a map of land and water cells.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">isWater[i][j]</span> <span class="pre">==</span> <span class="pre">0</span></code>, cell (i, j) is a land cell.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">isWater[i][j]</span> <span class="pre">==</span> <span class="pre">1</span></code>, cell (i, j) is a water cell.</p></li>
</ul>
<p>You must assign each cell a height in a way that follows these rules:</p>
<ul class="simple">
<li><p>The height of each cell must be non-negative.</p></li>
<li><p>If the cell is a water cell, its height must be 0.</p></li>
<li><p>Any two adjacent cells must have an absolute height difference of at most 1. A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).</p></li>
</ul>
<p>Find an assignment of heights such that the maximum height in the matrix is maximized.</p>
<p>Return an integer matrix <code class="docutils literal notranslate"><span class="pre">height</span></code> of size m x n where <code class="docutils literal notranslate"><span class="pre">height[i][j]</span></code> is cell (i, j)’s height. If there are multiple solutions, return any of them.</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">isWater</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">The</span> <span class="n">image</span> <span class="n">shows</span> <span class="n">the</span> <span class="n">assigned</span> <span class="n">heights</span> <span class="n">of</span> <span class="n">each</span> <span class="n">cell</span><span class="o">.</span>
<span class="n">The</span> <span class="n">blue</span> <span class="n">cell</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">water</span> <span class="n">cell</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">green</span> <span class="n">cells</span> <span class="n">are</span> <span class="n">the</span> <span class="n">land</span> <span class="n">cells</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Example 2:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">isWater</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">A</span> <span class="n">height</span> <span class="n">of</span> <span class="mi">2</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">possible</span> <span class="n">height</span> <span class="n">of</span> <span class="nb">any</span> <span class="n">assignment</span><span class="o">.</span>
<span class="n">Any</span> <span class="n">height</span> <span class="n">assignment</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">height</span> <span class="n">of</span> <span class="mi">2</span> <span class="k">while</span> <span class="n">still</span> <span class="n">meeting</span> <span class="n">the</span> <span class="n">rules</span> <span class="n">will</span> <span class="n">also</span> <span class="n">be</span> <span class="n">accepted</span><span class="o">.</span>
</pre></div>
</div>
<p><strong>Constraints:</strong></p>
<ul class="simple">
<li><p>m == isWater.length</p></li>
<li><p>n == isWater[i].length</p></li>
<li><p>1 &lt;= m, n &lt;= 1000</p></li>
<li><p>isWater[i][j] is 0 or 1.</p></li>
<li><p>There is at least one water cell.</p></li>
</ul>
<p><strong>Approach:</strong></p>
<p>We can solve this problem using BFS (Breadth-First Search) starting from water cells. We will iterate over each water cell and perform BFS to assign heights to adjacent land cells.</p>
<ol class="arabic simple">
<li><p>Initialize an empty queue for BFS, and a <code class="docutils literal notranslate"><span class="pre">height</span></code> matrix with initial values as -1.</p></li>
<li><p>Iterate over each water cell (i, j):</p>
<ul class="simple">
<li><p>Enqueue the water cell (i, j) in the queue with height 0.</p></li>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">height[i][j]</span></code> to 0.</p></li>
</ul>
</li>
<li><p>Start BFS:</p>
<ul class="simple">
<li><p>Dequeue a cell (i, j) from the queue.</p></li>
<li><p>Iterate over adjacent cells:</p>
<ul>
<li><p>If the adjacent cell is within bounds and has not been visited yet:</p>
<ul>
<li><p>Set <code class="docutils literal notranslate"><span class="pre">height[ni][nj]</span></code> to <code class="docutils literal notranslate"><span class="pre">height[i][j]</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p></li>
<li><p>Enqueue the adjacent cell (ni, nj) in the queue.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Return the <code class="docutils literal notranslate"><span class="pre">height</span></code> matrix.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">highestPeak</span><span class="p">(</span><span class="n">isWater</span><span class="p">):</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">isWater</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">isWater</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">height</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isWater</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="n">dj</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]:</span>
            <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">di</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">dj</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ni</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nj</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">height</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">height</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">nj</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="n">nj</span><span class="p">,</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">height</span>

<span class="c1"># Test cases</span>
<span class="n">isWater1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">highestPeak</span><span class="p">(</span><span class="n">isWater1</span><span class="p">))</span>  <span class="c1"># Output: [[1,0],[2,1]]</span>

<span class="n">isWater2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">highestPeak</span><span class="p">(</span><span class="n">isWater2</span><span class="p">))</span>  <span class="c1"># Output: [[1,1,0],[0,1,1],[1,2,2]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[1, 0], [2, 1]]
[[1, 1, 0], [0, 1, 1], [1, 2, 2]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-29-bus-routes">
<h3><strong>Problem #29 Bus Routes</strong><a class="headerlink" href="#problem-29-bus-routes" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/bus-routes/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>You are given an array <code class="docutils literal notranslate"><span class="pre">routes</span></code> representing bus routes where <code class="docutils literal notranslate"><span class="pre">routes[i]</span></code> is a bus route that the ith bus repeats forever.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">routes[0]</span> <span class="pre">=</span> <span class="pre">[1,</span> <span class="pre">5,</span> <span class="pre">7]</span></code>, this means that the 0th bus travels in the sequence 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; 5 -&gt; 7 -&gt; 1 -&gt; … forever.</p>
<p>You will start at the bus stop <code class="docutils literal notranslate"><span class="pre">source</span></code> (You are not on any bus initially), and you want to go to the bus stop <code class="docutils literal notranslate"><span class="pre">target</span></code>. You can travel between bus stops by buses only.</p>
<p>Return the least number of buses you must take to travel from <code class="docutils literal notranslate"><span class="pre">source</span></code> to <code class="docutils literal notranslate"><span class="pre">target</span></code>. Return -1 if it is not possible.</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">routes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]],</span> <span class="n">source</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">The</span> <span class="n">best</span> <span class="n">strategy</span> <span class="ow">is</span> <span class="n">take</span> <span class="n">the</span> <span class="n">first</span> <span class="n">bus</span> <span class="n">to</span> <span class="n">the</span> <span class="n">bus</span> <span class="n">stop</span> <span class="mi">7</span><span class="p">,</span> <span class="n">then</span> <span class="n">take</span> <span class="n">the</span> <span class="n">second</span> <span class="n">bus</span> <span class="n">to</span> <span class="n">the</span> <span class="n">bus</span> <span class="n">stop</span> <span class="mf">6.</span>
</pre></div>
</div>
<p><strong>Example 2:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">routes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">12</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">15</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">15</span><span class="p">,</span><span class="mi">19</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">]],</span> <span class="n">source</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">12</span>
<span class="n">Output</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p><strong>Approach:</strong></p>
<p>We can solve this problem using BFS (Breadth-First Search) by treating each bus stop as a node in a graph and each bus route as an edge between the stops it covers.</p>
<ol class="arabic simple">
<li><p>Create a graph where each bus stop is a node and add edges between stops that are covered by the same bus route.</p></li>
<li><p>Use BFS to find the shortest path from the <code class="docutils literal notranslate"><span class="pre">source</span></code> stop to the <code class="docutils literal notranslate"><span class="pre">target</span></code> stop.</p></li>
<li><p>Return the length of the shortest path as the result. If the target stop is unreachable, return -1.</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">numBusesToDestination</span><span class="p">(</span><span class="n">routes</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">stop_to_buses</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">route</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">routes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">route</span><span class="p">:</span>
            <span class="n">stop_to_buses</span><span class="p">[</span><span class="n">stop</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">visited_stops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">visited_routes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">source</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">stop</span><span class="p">,</span> <span class="n">num_buses</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">num_buses</span>
        <span class="n">visited_stops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bus</span> <span class="ow">in</span> <span class="n">stop_to_buses</span><span class="p">[</span><span class="n">stop</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">bus</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_routes</span><span class="p">:</span>
                <span class="n">visited_routes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bus</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">next_stop</span> <span class="ow">in</span> <span class="n">routes</span><span class="p">[</span><span class="n">bus</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">next_stop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_stops</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">next_stop</span><span class="p">,</span> <span class="n">num_buses</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test cases</span>
<span class="n">routes1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
<span class="n">source1</span><span class="p">,</span> <span class="n">target1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numBusesToDestination</span><span class="p">(</span><span class="n">routes1</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">target1</span><span class="p">))</span>  <span class="c1"># Output: 2</span>

<span class="n">routes2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">7</span><span class="p">,</span><span class="mi">12</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">15</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">15</span><span class="p">,</span><span class="mi">19</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">]]</span>
<span class="n">source2</span><span class="p">,</span> <span class="n">target2</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">12</span>
<span class="nb">print</span><span class="p">(</span><span class="n">numBusesToDestination</span><span class="p">(</span><span class="n">routes2</span><span class="p">,</span> <span class="n">source2</span><span class="p">,</span> <span class="n">target2</span><span class="p">))</span>  <span class="c1"># Output: -1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
-1
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-30-as-far-from-land-as-possible">
<h3><strong>Problem #30 As Far from Land as Possible</strong><a class="headerlink" href="#problem-30-as-far-from-land-as-possible" title="Link to this heading">#</a></h3>
<p><a class="reference external" href="https://leetcode.com/problems/as-far-from-land-as-possible/description/">Link to problem description</a></p>
<p><strong>Problem Statement:</strong></p>
<p>Given an <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">x</span> <span class="pre">n</span></code> grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1.</p>
<p>The distance used in this problem is the Manhattan distance: the distance between two cells <code class="docutils literal notranslate"><span class="pre">(x0,</span> <span class="pre">y0)</span></code> and <code class="docutils literal notranslate"><span class="pre">(x1,</span> <span class="pre">y1)</span></code> is <code class="docutils literal notranslate"><span class="pre">|x0</span> <span class="pre">-</span> <span class="pre">x1|</span> <span class="pre">+</span> <span class="pre">|y0</span> <span class="pre">-</span> <span class="pre">y1|</span></code>.</p>
<p><strong>Example 1:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">The</span> <span class="n">cell</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="k">as</span> <span class="n">far</span> <span class="k">as</span> <span class="n">possible</span> <span class="kn">from</span> <span class="nn">all</span> <span class="n">the</span> <span class="n">land</span> <span class="k">with</span> <span class="n">distance</span> <span class="mf">2.</span>
</pre></div>
</div>
<p><strong>Example 2:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Input</span><span class="p">:</span> <span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">Output</span><span class="p">:</span> <span class="mi">4</span>
<span class="n">Explanation</span><span class="p">:</span> <span class="n">The</span> <span class="n">cell</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">is</span> <span class="k">as</span> <span class="n">far</span> <span class="k">as</span> <span class="n">possible</span> <span class="kn">from</span> <span class="nn">all</span> <span class="n">the</span> <span class="n">land</span> <span class="k">with</span> <span class="n">distance</span> <span class="mf">4.</span>
</pre></div>
</div>
<p><strong>Approach:</strong></p>
<p>We can solve this problem using BFS (Breadth-First Search). We’ll start by adding all the land cells to a queue and mark them as visited. Then, we’ll perform BFS starting from the land cells to explore all the water cells and calculate their distances from the nearest land cell. Finally, we’ll return the maximum distance found.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">maxDistance</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">directions</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>

    <span class="c1"># Initialize a queue to store land cells</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="c1"># Add all land cells to the queue and mark them as visited</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Mark visited land cells</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># If there are no land cells or all cells are land, return -1</span>

    <span class="c1"># Perform BFS to calculate distances from land cells to water cells</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">nx</span><span class="p">][</span><span class="n">ny</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">))</span>

    <span class="c1"># Return the maximum distance found</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">grid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

<span class="c1"># Test cases</span>
<span class="n">grid1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">maxDistance</span><span class="p">(</span><span class="n">grid1</span><span class="p">))</span>  <span class="c1"># Output: 1</span>

<span class="n">grid2</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">maxDistance</span><span class="p">(</span><span class="n">grid2</span><span class="p">))</span>  <span class="c1"># Output: 2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
2
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="conclusion">
<h2><strong>Conclusion</strong><a class="headerlink" href="#conclusion" title="Link to this heading">#</a></h2>
<p>In conclusion, graph traversal is a fundamental concept in computer science with wide-ranging applications across various domains. Throughout this chapter, we have delved into the intricacies of graph traversal algorithms, starting with the fundamental Breadth-First Search (BFS) and Depth-First Search (DFS) techniques.</p>
<p>We explored how BFS explores nodes level by level, making it suitable for tasks like shortest path finding and network analysis, while DFS explores nodes deeply, making it useful for tasks like topological sorting and cycle detection.</p>
<p>Additionally, we compared BFS and DFS traversal approaches, highlighting their differences in traversal order, data structures used, and example use cases. We also delved into various other graph traversal algorithms, such as Dijkstra’s, A* Search, Prim’s, Kruskal’s, Tarjan’s, Kosaraju’s, Ford-Fulkerson, and Edmonds-Karp, each with its unique characteristics and applications.</p>
<p>Moreover, we discussed the significance of graph traversal in computer science applications, including network analysis, pathfinding, recommendation systems, and more.</p>
<p>Finally, we provided valuable tips for solving problems with graph traversal algorithms, emphasizing the importance of understanding the problem, choosing the right algorithm, handling graph representations, optimizing time and space complexity, and continuous practice.</p>
<p>By mastering graph traversal techniques and applying them effectively, one can efficiently tackle complex problems and contribute to advancements in various fields. With continuous learning, practice, and exploration, the journey through graph traversal opens up endless possibilities for innovation and problem-solving.</p>
<p>Through this comprehensive exploration, we hope to have provided you with a solid foundation in graph traversal and inspired you to further explore and apply these concepts in your future endeavors.</p>
<hr class="docutils" />
<p>In summary, the chapter on graph traversal aims to equip readers with a comprehensive understanding of various traversal techniques, their applications, and problem-solving strategies. If there are any specific questions or areas you would like to explore further, feel free to delve deeper into the references and useful links provided.</p>
<section id="key-takeaways">
<h3><strong>Key takeaways</strong><a class="headerlink" href="#key-takeaways" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p>Graph Traversal: Graph Traversal involves the process of visiting and exploring each vertex or node in a graph. Two fundamental techniques for this are Breadth-First Search (BFS) and Depth-First Search (DFS).</p></li>
<li><p>Breadth-First Search (BFS): BFS is a strategy that exhausts all neighbours of a node before moving to the next level neighbours. It is implemented using a queue data structure. BFS traversal is used for tasks like finding the shortest path in an unweighted graph or level order traversal of a tree.</p></li>
<li><p>Depth-First Search (DFS): DFS is a technique that explores as far as possible along each branch of the graph before backtracking. It is implemented using a stack data structure and is preferred for tasks like Topological Sorting or detecting a cycle in a graph.</p></li>
<li><p>Undirected Graph Traversal: An undirected graph is a graph in which edges have no orientation. Traversal of such graphs requires maintaining a boolean array to record the visited nodes to avoid repetitions. Both BFS and DFS can be used for traversing undirected graphs.</p></li>
<li><p>Comparative Overview of BFS and DFS: BFS traverses the graph level by level using a queue data structure and is beneficial for finding the shortest path in an unweighted graph. DFS carries out depth-first traversal using a stack data structure, retracing when it hits a dead end, beneficial for topological sorting or detecting a cycle in a graph.</p></li>
</ul>
</section>
</section>
<section id="references">
<h2><strong>References</strong><a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>LeetCode Breadth-First Search (BFS) Tag: <a class="reference external" href="https://leetcode.com/tag/breadth-first-search/">https://leetcode.com/tag/breadth-first-search/</a></p></li>
<li><p>LeetCode Discussion on BFS and DFS Graph Problems: <a class="reference external" href="https://leetcode.com/discuss/interview-question/operating-system/5039797/BFS-and-DFS-Graph-Problems%3A-Easy-to-Medium-Difficulty/">https://leetcode.com/discuss/interview-question/operating-system/5039797/BFS-and-DFS-Graph-Problems%3A-Easy-to-Medium-Difficulty/</a></p></li>
<li><p>LeetCode Study Guide on Graph Traversal Problems: <a class="reference external" href="https://leetcode.com/discuss/study-guide/3903992/graph-its-implementation-and-some-popular-bfsdfs-problems">https://leetcode.com/discuss/study-guide/3903992/graph-its-implementation-and-some-popular-bfsdfs-problems</a></p></li>
<li><p>Graphable: Best Graph Traversal Algorithms: <a class="reference external" href="https://www.graphable.ai/blog/best-graph-traversal-algorithms/">https://www.graphable.ai/blog/best-graph-traversal-algorithms/</a></p></li>
<li><p>Medium Article: Graph Algorithms - Traversals, Shortest Paths, and Beyond: <a class="reference external" href="https://medium.com/&#64;beyond_verse/graph-algorithms-traversals-shortest-paths-and-beyond-671f611aa025">https://medium.com/&#64;beyond_verse/graph-algorithms-traversals-shortest-paths-and-beyond-671f611aa025</a></p></li>
<li><p>OpenDSA: Graph Traversal Chapter: <a class="reference external" href="https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/GraphTraversal.html">https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/GraphTraversal.html</a></p></li>
<li><p>Study Smarter: Explanation of Graph Traversal Algorithms: <a class="reference external" href="https://www.studysmarter.co.uk/explanations/computer-science/algorithms-in-computer-science/graph-traversal/">https://www.studysmarter.co.uk/explanations/computer-science/algorithms-in-computer-science/graph-traversal/</a></p></li>
</ol>
<ul class="simple">
<li><p>NetworkX Documentation: <a class="reference external" href="https://networkx.org/documentation/stable/index.html">https://networkx.org/documentation/stable/index.html</a></p></li>
<li><p>GeeksforGeeks Graph Traversal Algorithms: <a class="reference external" href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/</a></p></li>
<li><p>Visualization of Algorithms: <a class="reference external" href="https://visualgo.net/en">https://visualgo.net/en</a></p></li>
<li><p>Khan Academy: Breadth-First and Depth-First Search: <a class="reference external" href="https://www.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/breadth-first-search-and-its-uses">https://www.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/breadth-first-search-and-its-uses</a></p></li>
<li><p>Coursera Algorithms Specialization: <a class="reference external" href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></p></li>
</ul>
<p><strong>Additional Papers:</strong></p>
<ul class="simple">
<li><p>Tarjan, R. E. (1972). Depth-first search and linear graph algorithms. <em>SIAM Journal on Computing</em>, 1(2), 146-160.</p></li>
<li><p>Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). <em>Introduction to Algorithms</em> (3rd ed.). MIT Press.</p></li>
</ul>
</section>
<section id="useful-links">
<h2><strong>Useful links</strong><a class="headerlink" href="#useful-links" title="Link to this heading">#</a></h2>
<section id="id3">
<h3><strong>Understanding Graph Traversal in Computer Science</strong><a class="headerlink" href="#id3" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Graph_traversal">Graph Traversal</a>: Wikipedia article providing an overview of graph traversal algorithms.</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph Traversal Techniques</a>: GeeksforGeeks article explaining different graph traversal techniques with examples.</p></li>
</ul>
</section>
<section id="id4">
<h3><strong>Breadth-First Search (BFS)</strong><a class="headerlink" href="#id4" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search (BFS)</a>: Wikipedia article on BFS algorithm with detailed explanation and pseudocode.</p></li>
<li><p><a class="reference external" href="https://www.tutorialspoint.com/data_structures_algorithms/breadth_first_traversal.htm">BFS Tutorial</a>: Tutorialspoint article explaining BFS with examples.</p></li>
</ul>
</section>
<section id="id5">
<h3><strong>Depth-First Search (DFS)</strong><a class="headerlink" href="#id5" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://en.wikipedia.org/wiki/Depth-first_search">Depth-First Search (DFS)</a>: Wikipedia article on DFS algorithm with detailed explanation and pseudocode.</p></li>
<li><p><a class="reference external" href="https://www.tutorialspoint.com/data_structures_algorithms/depth_first_traversal.htm">DFS Tutorial</a>: Tutorialspoint article explaining DFS with examples.</p></li>
</ul>
</section>
<section id="id6">
<h3><strong>Exploring Different Graph Traversal Algorithms</strong><a class="headerlink" href="#id6" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/breadth-first-search-and-its-uses">Graph Traversal Algorithms</a>: Khan Academy article exploring different graph traversal algorithms and their uses.</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Algorithms</a>: GeeksforGeeks article covering various graph algorithms, including traversal algorithms.</p></li>
</ul>
</section>
<section id="id7">
<h3><strong>The Applications of Graph Traversal in Computer Science</strong><a class="headerlink" href="#id7" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/applications-of-graph-data-structure/">Applications of Graph Traversal</a>: GeeksforGeeks article discussing various applications of graph traversal in computer science.</p></li>
<li><p><a class="reference external" href="https://courses.cs.washington.edu/courses/cse373/06sp/handouts/Lecture18.pdf">Graph Traversal Applications</a>: Lecture slides from the University of Washington covering applications of graph traversal algorithms.</p></li>
</ul>
</section>
<section id="tips">
<h3><strong>Tips</strong><a class="headerlink" href="#tips" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://www.hackerearth.com/practice/algorithms/graphs/graph-traversal/tutorial/">Graph Traversal Tips</a>: HackerEarth tutorial offering tips and tricks for implementing graph traversal algorithms.</p></li>
<li><p><a class="reference external" href="https://www.topcoder.com/thrive/articles/Graph%20Traversal%20Techniques">Graph Traversal Techniques</a>: Topcoder article providing insights and best practices for graph traversal.</p></li>
</ul>
</section>
<section id="problems">
<h3><strong>Problems</strong><a class="headerlink" href="#problems" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://leetcode.com/tag/graph-traversal/">Graph Traversal Problems</a>: LeetCode tag for graph traversal problems with a collection of practice problems.</p></li>
<li><p><a class="reference external" href="https://www.hackerearth.com/practice/algorithms/graphs/graph-traversal/problems/">Graph Traversal Challenges</a>: HackerEarth collection of graph traversal challenges for practice.</p></li>
</ul>
</section>
<section id="solution-graph-traversal-key-takeaways">
<h3><strong>Solution / Graph Traversal - Key Takeaways</strong><a class="headerlink" href="#solution-graph-traversal-key-takeaways" title="Link to this heading">#</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://cp-algorithms.com/graph/graph_traversal.html">Graph Traversal Summary</a>: Competitive Programming Algorithms website offering a summary of graph traversal algorithms and their key takeaways.</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/#traversal">Graph Traversal Solutions</a>: GeeksforGeeks section providing solutions and implementations of graph traversal algorithms.</p></li>
</ul>
<p>These resources offer a wealth of information, tutorials, practice problems, and solutions related to understanding graph traversal algorithms and their applications in computer science.</p>
</section>
</section>
<section id="thank-you">
<h2><strong>Thank you!</strong><a class="headerlink" href="#thank-you" title="Link to this heading">#</a></h2>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Chapter6.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><strong>Data Structures: Trees and Graphs</strong></p>
      </div>
    </a>
    <a class="right-next"
       href="Chapter8.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Graph Shortest Paths</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#table-of-contents"><strong>TABLE OF CONTENTS:</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#understanding-graph-traversal-in-computer-science"><strong>Understanding Graph Traversal in Computer Science</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-definition-of-graph-traversal"><strong>The Definition of Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-terminology-in-graph-traversal"><strong>Key Terminology in Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-role-of-graph-traversal-in-data-structures"><strong>The Role of Graph Traversal in Data Structures</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#breadth-first-search-bfs"><strong>Breadth-First Search (BFS)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1"><strong>Example #1</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-bfs-traversal-of-a-directed-graph"><strong>Example #2 BFS Traversal of a Directed Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applications-and-use-cases"><strong>Applications and Use Cases</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#depth-first-search-dfs"><strong>Depth-First Search (DFS)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id1"><strong>Example #1</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-dfs-traversal-of-a-directed-graph"><strong>Example #2 DFS Traversal of a Directed Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id2"><strong>Applications and Use Cases</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#comparing-bfs-and-dfs-graph-traversal-approaches"><strong>Comparing BFS and DFS Graph Traversal Approaches</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example"><strong>Example</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exploring-different-graph-traversal-algorithms"><strong>Exploring Different Graph Traversal Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#fundamentals-of-graph-traversal-algorithms"><strong>Fundamentals of Graph Traversal Algorithms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path-algorithms"><strong>Shortest Path Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#dijkstras-algorithm"><strong>Dijkstra’s Algorithm</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bellman-ford-algorithm"><strong>Bellman-Ford Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree"><strong>Minimum Spanning Tree</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#prims-algorithm"><strong>Prim’s Algorithm</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kruskals-algorithm"><strong>Kruskal’s Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#strongly-connected-components-sccs"><strong>Strongly Connected Components (SCCs)</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#kosarajus-algorithm"><strong>Kosaraju’s Algorithm</strong></a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#flow-algorithms"><strong>Flow Algorithms</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ford-fulkerson-algorithm-for-maximum-flow"><strong>Ford-Fulkerson Algorithm for Maximum Flow</strong></a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#edmonds-karp-algorithm"><strong>Edmonds-Karp Algorithm</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-applications-of-graph-traversal-in-computer-science"><strong>The Applications of Graph Traversal in Computer Science</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#real-world-applications-of-graph-traversal"><strong>Real-World Applications of Graph Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-graph-traversal-is-changing-the-tech-industry"><strong>How Graph Traversal is Changing the Tech Industry</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tips-for-solving-problems-with-graph-traversal-algorithms"><strong>Tips for Solving Problems with Graph Traversal Algorithms</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#leetcode-problems-related-to-graph-traversals"><strong>Leetcode Problems related to Graph Traversals</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-1-number-of-provincies"><strong>Problem #1 Number of Provincies</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-2-rotting-oranges"><strong>Problem #2 Rotting Oranges</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-3-flood-fill"><strong>Problem #3 Flood Fill</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-4-surrounded-regions"><strong>Problem #4 Surrounded Regions</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-5-number-of-enclaves"><strong>Problem #5 Number of Enclaves</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-6-is-graph-bipartite"><strong>Problem #6 Is Graph Bipartite?</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-7-number-of-islands"><strong>Problem #7 Number of Islands</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-8-word-ladder"><strong>Problem #8 Word Ladder</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-9-shortest-path-in-binary-matrix"><strong>Problem #9 Shortest Path in Binary Matrix</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-10-word-search"><strong>Problem #10 Word Search</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-11-symmetric-tree"><strong>Problem #11 Symmetric Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-12-path-sum"><strong>Problem #12 Path Sum</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-13-binary-tree-level-order-traversal"><strong>Problem #13 Binary Tree Level Order Traversal</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-14-pacific-atlantic-water-flow"><strong>Problem #14 Pacific Atlantic Water Flow</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-15-course-schedule"><strong>Problem #15 Course Schedule</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-16-network-delay-time"><strong>Problem #16 Network Delay Time</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-17-same-tree"><strong>Problem #17 Same Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-18-maximum-depth-of-binary-tree"><strong>Problem #18 Maximum Depth of Binary Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-19-minimum-depth-of-binary-tree"><strong>Problem #19 Minimum Depth of Binary Tree</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-20-clone-graph"><strong>Problem #20 Clone Graph</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-21-perfect-squares"><strong>Problem #21 Perfect Squares</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-22-coin-change"><strong>Problem #22 Coin Change</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-23-water-and-jug-problem"><strong>Problem #23 Water and Jug Problem</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-24-sum-of-left-leaves"><strong>Problem #24 Sum of Left Leaves</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-25-zuma-game"><strong>Problem #25 Zuma Game</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-26-keys-and-rooms"><strong>Problem #26 Keys and Rooms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-27-escape-the-spreading-fire"><strong>Problem #27 Escape the Spreading Fire</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-28-map-of-highest-peak"><strong>Problem #28 Map of Highest Peak</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-29-bus-routes"><strong>Problem #29 Bus Routes</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problem-30-as-far-from-land-as-possible"><strong>Problem #30 As Far from Land as Possible</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conclusion"><strong>Conclusion</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#key-takeaways"><strong>Key takeaways</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references"><strong>References</strong></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#useful-links"><strong>Useful links</strong></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id3"><strong>Understanding Graph Traversal in Computer Science</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id4"><strong>Breadth-First Search (BFS)</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5"><strong>Depth-First Search (DFS)</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6"><strong>Exploring Different Graph Traversal Algorithms</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7"><strong>The Applications of Graph Traversal in Computer Science</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tips"><strong>Tips</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#problems"><strong>Problems</strong></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-graph-traversal-key-takeaways"><strong>Solution / Graph Traversal - Key Takeaways</strong></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#thank-you"><strong>Thank you!</strong></a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The Jupyter Book Community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>